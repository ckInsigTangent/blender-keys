#+TITLE: Blender Operator List
* bpy.ops.action
** Add keyframes on every frame between the selected keyframes
#+BEGIN_SRC python
  .sample()
#+END_SRC
** Copy selected keyframes to the copy/paste buffer
#+BEGIN_SRC python
  .copy()
#+END_SRC
** Create new action
#+BEGIN_SRC python
  .new()
#+END_SRC
** Deselect keyframes on ends of selection islands
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Flip selected keyframes over the selected mirror line
#+BEGIN_SRC python
  .mirror(type='CFRA')
#+END_SRC
** Insert keyframes for the specified channels
#+BEGIN_SRC python
  .keyframe_insert(type='ALL')
#+END_SRC
** Make a copy of all selected keyframes
#+BEGIN_SRC python
  .duplicate()
#+END_SRC
** Make a copy of all selected keyframes and move them
#+BEGIN_SRC python
  .duplicate_move(ACTION_OT_duplicate={}, TRANSFORM_OT_transform={"mode":'TRANSLATION', "value":(0, 0, 0, 0), "axis":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False})
#+END_SRC
** Move selected scene markers to the active Action as local 'pose' markers
#+BEGIN_SRC python
  .markers_make_local()
#+END_SRC
** Paste keyframes from copy/paste buffer for the selected channels, starting on the current frame
#+BEGIN_SRC python
  .paste(offset='START', merge='MIX')
#+END_SRC
** Remove all selected keyframes
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Reset viewable area to show full keyframe range
#+BEGIN_SRC python
  .view_all()
#+END_SRC
** Reset viewable area to show selected keyframes range
#+BEGIN_SRC python
  .view_selected()
#+END_SRC
** Select all keyframes on the specified frame(s)
#+BEGIN_SRC python
  .select_column(mode='KEYS')
#+END_SRC
** Select all keyframes within the specified region
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, axis_range=False)
#+END_SRC
** Select keyframes beside already selected ones
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select keyframes by clicking on them
#+BEGIN_SRC python
  .clickselect(extend=False, column=False, channel=False)
#+END_SRC
** Select keyframes occurring in the same F-Curves as selected ones
#+BEGIN_SRC python
  .select_linked()
#+END_SRC
** Select keyframes to the left or the right of the current frame
#+BEGIN_SRC python
  .select_leftright(mode='CHECK', extend=False)
#+END_SRC
** Set Preview Range based on extents of selected Keyframes
#+BEGIN_SRC python
  .previewrange_set()
#+END_SRC
** Set extrapolation mode for selected F-Curves
#+BEGIN_SRC python
  .extrapolation_type(type='CONSTANT')
#+END_SRC
** Set interpolation mode for the F-Curve segments starting from the selected keyframes
#+BEGIN_SRC python
  .interpolation_type(type='CONSTANT')
#+END_SRC
** Set the current frame to the average frame value of selected keyframes
#+BEGIN_SRC python
  .frame_jump()
#+END_SRC
** Set type of handle for selected keyframes
#+BEGIN_SRC python
  .handle_type(type='FREE')
#+END_SRC
** Set type of keyframe for the selected keyframes
#+BEGIN_SRC python
  .keyframe_type(type='KEYFRAME')
#+END_SRC
** Simplify F-Curves by removing closely spaced keyframes
#+BEGIN_SRC python
  .clean(threshold=0.001)
#+END_SRC
** Snap selected keyframes to the times specified
#+BEGIN_SRC python
  .snap(type='CFRA')
#+END_SRC
** Toggle selection of all keyframes
#+BEGIN_SRC python
  .select_all_toggle(invert=False)
#+END_SRC
* bpy.ops.anim
** Add a new (empty) Keying Set to the active Scene
#+BEGIN_SRC python
  .keying_set_add()
#+END_SRC
** Add current UI-active property to current keying set
#+BEGIN_SRC python
  .keyingset_button_add(all=True)
#+END_SRC
** Add driver(s) for the property(s) connected represented by the highlighted button
#+BEGIN_SRC python
  .driver_button_add(all=True)
#+END_SRC
** Add empty path to active Keying Set
#+BEGIN_SRC python
  .keying_set_path_add()
#+END_SRC
** Add selected F-Curves to a new group
#+BEGIN_SRC python
  .channels_group(name="New Group")
#+END_SRC
** Clear Preview Range
#+BEGIN_SRC python
  .previewrange_clear()
#+END_SRC
** Clear all keyframes on the currently active property
#+BEGIN_SRC python
  .keyframe_clear_button(all=True)
#+END_SRC
** Clears 'disabled' tag from all F-Curves to get broken F-Curves working again
#+BEGIN_SRC python
  .channels_fcurves_enable()
#+END_SRC
** Collapse (i.e. close) all selected expandable animation channels
#+BEGIN_SRC python
  .channels_collapse(all=True)
#+END_SRC
** Copy the driver for the highlighted button
#+BEGIN_SRC python
  .copy_driver_button()
#+END_SRC
** Delete all selected animation channels
#+BEGIN_SRC python
  .channels_delete()
#+END_SRC
** Delete current keyframe of current UI-active property
#+BEGIN_SRC python
  .keyframe_delete_button(all=True)
#+END_SRC
** Delete keyframes on the current frame for all properties in the specified Keying Set
#+BEGIN_SRC python
  .keyframe_delete(type='DEFAULT', confirm_success=True)
#+END_SRC
** Disable specified setting on all selected animation channels
#+BEGIN_SRC python
  .channels_setting_disable(mode='DISABLE', type='PROTECT')
#+END_SRC
** Enable specified setting on all selected animation channels
#+BEGIN_SRC python
  .channels_setting_enable(mode='ENABLE', type='PROTECT')
#+END_SRC
** Expand (i.e. open) all selected expandable animation channels
#+BEGIN_SRC python
  .channels_expand(all=True)
#+END_SRC
** Export Keying Set to a python script
#+BEGIN_SRC python
  .keying_set_export(filepath="", filter_folder=True, filter_text=True, filter_python=True)
#+END_SRC
** Handle mouse-clicks over animation channels
#+BEGIN_SRC python
  .channels_click(extend=False, children_only=False)
#+END_SRC
** Insert Keyframes for specified Keying Set, with menu of available Keying Sets if undefined
#+BEGIN_SRC python
  .keyframe_insert_menu(type='DEFAULT', confirm_success=False, always_prompt=False)
#+END_SRC
** Insert a keyframe for current UI-active property
#+BEGIN_SRC python
  .keyframe_insert_button(all=True)
#+END_SRC
** Insert keyframes on the current frame for all properties in the specified Keying Set
#+BEGIN_SRC python
  .keyframe_insert(type='DEFAULT', confirm_success=True)
#+END_SRC
** Interactively change the current frame number
#+BEGIN_SRC python
  .change_frame(frame=0)
#+END_SRC
** Interactively define frame range used for playback
#+BEGIN_SRC python
  .previewrange_set(xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** Make only the selected animation channels visible in the Graph Editor
#+BEGIN_SRC python
  .channels_visibility_set()
#+END_SRC
** Mark actions with no F-Curves for deletion after save & reload of file preserving "action libraries"
#+BEGIN_SRC python
  .clear_useless_actions(only_unused=True)
#+END_SRC
** Paste the driver in the copy/paste buffer for the highlighted button
#+BEGIN_SRC python
  .paste_driver_button()
#+END_SRC
** Rearrange selected animation channels
#+BEGIN_SRC python
  .channels_move(direction='DOWN')
#+END_SRC
** Remove active Path from active Keying Set
#+BEGIN_SRC python
  .keying_set_path_remove()
#+END_SRC
** Remove all keyframe animation for selected objects
#+BEGIN_SRC python
  .keyframe_clear_v3d()
#+END_SRC
** Remove current UI-active property from current keying set
#+BEGIN_SRC python
  .keyingset_button_remove()
#+END_SRC
** Remove keyframes on current frame for selected objects
#+BEGIN_SRC python
  .keyframe_delete_v3d()
#+END_SRC
** Remove selected F-Curves from their current groups
#+BEGIN_SRC python
  .channels_ungroup()
#+END_SRC
** Remove the active Keying Set
#+BEGIN_SRC python
  .keying_set_remove()
#+END_SRC
** Remove the driver(s) for the property(s) connected represented by the highlighted button
#+BEGIN_SRC python
  .driver_button_remove(all=True)
#+END_SRC
** Rename animation channel under mouse
#+BEGIN_SRC python
  .channels_rename()
#+END_SRC
** Select a new keying set as the active one
#+BEGIN_SRC python
  .keying_set_active_set(type='DEFAULT')
#+END_SRC
** Select all animation channels within the specified region
#+BEGIN_SRC python
  .channels_select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Toggle editability of selected channels
#+BEGIN_SRC python
  .channels_editable_toggle(mode='TOGGLE', type='PROTECT')
#+END_SRC
** Toggle selection of all animation channels
#+BEGIN_SRC python
  .channels_select_all_toggle(invert=False)
#+END_SRC
** Toggle specified setting on all selected animation channels
#+BEGIN_SRC python
  .channels_setting_toggle(mode='TOGGLE', type='PROTECT')
#+END_SRC
** Toggle visibility in Graph Editor of all selected animation channels
#+BEGIN_SRC python
  .channels_visibility_toggle()
#+END_SRC
** Update data paths from 2.56 and previous versions, modifying data paths of drivers and fcurves
#+BEGIN_SRC python
  .update_data_paths()
#+END_SRC
* bpy.ops.armature
** Add a new bone located at the 3D-Cursor
#+BEGIN_SRC python
  .bone_primitive_add(name="Bone")
#+END_SRC
** Add bone between selected joint(s) and/or 3D-Cursor
#+BEGIN_SRC python
  .fill()
#+END_SRC
** Align selected bones to the active bone (or to their parent)
#+BEGIN_SRC python
  .align()
#+END_SRC
** Automatically fix alignment of select bones' axes
#+BEGIN_SRC python
  .calculate_roll(type='X', axis_flip=False, axis_only=False)
#+END_SRC
** Automatically renames the selected bones according to which side of the target axis they fall on
#+BEGIN_SRC python
  .autoside_names(type='XAXIS')
#+END_SRC
** Break selected bones into chains of smaller bones
#+BEGIN_SRC python
  .subdivide(number_cuts=1)
#+END_SRC
** Change the direction that a chain of bones points in (head <-> tail swap)
#+BEGIN_SRC python
  .switch_direction()
#+END_SRC
** Change the layers that the selected bones belong to
#+BEGIN_SRC python
  .bone_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Change the visible armature layers
#+BEGIN_SRC python
  .armature_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Create a new bone going from the last selected joint to the mouse position
#+BEGIN_SRC python
  .click_extrude()
#+END_SRC
** Create new bones from the selected joints
#+BEGIN_SRC python
  .extrude(forked=False)
#+END_SRC
** Create new bones from the selected joints and move them
#+BEGIN_SRC python
  .extrude_forked(ARMATURE_OT_extrude={"forked":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Create new bones from the selected joints and move them
#+BEGIN_SRC python
  .extrude_move(ARMATURE_OT_extrude={"forked":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Deselect those bones at the boundary of each selection region
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Flip the selection status of bones (selected -> unselected, unselected -> selected)
#+BEGIN_SRC python
  .select_inverse()
#+END_SRC
** Flips (and corrects) the axis suffixes of the names of selected bones
#+BEGIN_SRC python
  .flip_names()
#+END_SRC
** Isolate selected bones into a separate armature
#+BEGIN_SRC python
  .separate()
#+END_SRC
** Make all armature layers visible
#+BEGIN_SRC python
  .layers_show_all(all=True)
#+END_SRC
** Make copies of the selected bones within the same armature
#+BEGIN_SRC python
  .duplicate()
#+END_SRC
** Make copies of the selected bones within the same armature and move them
#+BEGIN_SRC python
  .duplicate_move(ARMATURE_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Merge continuous chains of selected bones
#+BEGIN_SRC python
  .merge(type='WITHIN_CHAIN')
#+END_SRC
** Remove selected bones from the armature
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Remove the parent-child relationship between selected bones and their parents
#+BEGIN_SRC python
  .parent_clear(type='CLEAR')
#+END_SRC
** Select bones related to selected ones by parent/child relationships
#+BEGIN_SRC python
  .select_linked(extend=False)
#+END_SRC
** Select immediate parent/children of selected bones
#+BEGIN_SRC python
  .select_hierarchy(direction='PARENT', extend=False)
#+END_SRC
** Select similar bones by property types
#+BEGIN_SRC python
  .select_similar(type='LENGTH', threshold=0.1)
#+END_SRC
** Select those bones connected to the initial selection
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Set the active bone as the parent of the selected bones
#+BEGIN_SRC python
  .parent_set(type='CONNECTED')
#+END_SRC
** Split off selected bones from connected unselected bones
#+BEGIN_SRC python
  .split()
#+END_SRC
** Tag selected bones to not be visible in Edit Mode
#+BEGIN_SRC python
  .hide(unselected=False)
#+END_SRC
** Toggle selection status of all bones
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Unhide all bones that have been tagged to be hidden in Edit Mode
#+BEGIN_SRC python
  .reveal()
#+END_SRC
* bpy.ops.boid
** Add a boid rule to the current boid state
#+BEGIN_SRC python
  .rule_add(type='GOAL')
#+END_SRC
** Add a boid state to the particle system
#+BEGIN_SRC python
  .state_add()
#+END_SRC
** Delete current boid rule
#+BEGIN_SRC python
  .rule_del()
#+END_SRC
** Delete current boid state
#+BEGIN_SRC python
  .state_del()
#+END_SRC
** Move boid rule down in the list
#+BEGIN_SRC python
  .rule_move_down()
#+END_SRC
** Move boid rule up in the list
#+BEGIN_SRC python
  .rule_move_up()
#+END_SRC
** Move boid state down in the list
#+BEGIN_SRC python
  .state_move_down()
#+END_SRC
** Move boid state up in the list
#+BEGIN_SRC python
  .state_move_up()
#+END_SRC
* bpy.ops.brush
** Add brush by mode type
#+BEGIN_SRC python
  .add()
#+END_SRC
** Change brush size by a scalar
#+BEGIN_SRC python
  .scale_size(scalar=1)
#+END_SRC
** Control the stencil brush
#+BEGIN_SRC python
  .stencil_control(mode='TRANSLATION', texmode='PRIMARY')
#+END_SRC
** Reset the stencil transformation to the default
#+BEGIN_SRC python
  .stencil_reset_transform(mask=False)
#+END_SRC
** Return brush to defaults based on current tool
#+BEGIN_SRC python
  .reset()
#+END_SRC
** Set active sculpt/paint brush from it's number
#+BEGIN_SRC python
  .active_index_set(mode="", index=0)
#+END_SRC
** Set brush shape
#+BEGIN_SRC python
  .curve_preset(shape='SMOOTH')
#+END_SRC
** Set the UV sculpt tool
#+BEGIN_SRC python
  .uv_sculpt_tool_set(tool='PINCH')
#+END_SRC
** When using an image texture, adjust the stencil size to fit the image aspect ratio
#+BEGIN_SRC python
  .stencil_fit_image_aspect(use_repeat=True, use_scale=True, mask=False)
#+END_SRC
* bpy.ops.buttons
** Display button panel toolbox
#+BEGIN_SRC python
  .toolbox()
#+END_SRC
** Open a directory browser, Hold Shift to open the file, Alt to browse containing directory
#+BEGIN_SRC python
  .directory_browse(directory="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=False, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Open a file browser, Hold Shift to open the file, Alt to browse containing directory
#+BEGIN_SRC python
  .file_browse(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=False, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
* bpy.ops.camera
** Add a Camera Preset
#+BEGIN_SRC python
  .preset_add(remove_active=False, name="")
#+END_SRC
* bpy.ops.clip
** Add a Clip Track Color Preset
#+BEGIN_SRC python
  .track_color_preset_add(remove_active=False, name="")
#+END_SRC
** Add a Tracking Camera Intrinsics  Preset
#+BEGIN_SRC python
  .camera_preset_add(remove_active=False, name="")
#+END_SRC
** Add a motion tracking settings preset
#+BEGIN_SRC python
  .tracking_settings_preset_add(remove_active=False, name="")
#+END_SRC
** Add new marker and move it on movie
#+BEGIN_SRC python
  .add_marker_move(CLIP_OT_add_marker={"location":(0, 0)}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Add new marker and slide it with mouse until mouse button release
#+BEGIN_SRC python
  .add_marker_slide(CLIP_OT_add_marker={"location":(0, 0)}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Add new object for tracking
#+BEGIN_SRC python
  .tracking_object_new()
#+END_SRC
** Add selected tracks to 2D stabilization tool
#+BEGIN_SRC python
  .stabilize_2d_add()
#+END_SRC
** Apply scale on solution itself to make distance between selected tracks equals to desired
#+BEGIN_SRC python
  .apply_solution_scale(distance=0)
#+END_SRC
** Automatically detect features and place markers to track
#+BEGIN_SRC python
  .detect_features(placement='FRAME', margin=16, min_trackability=16, min_distance=120)
#+END_SRC
** Change selection of all markers of active track
#+BEGIN_SRC python
  .graph_select_all_markers(action='TOGGLE')
#+END_SRC
** Change selection of all tracking markers
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Clean tracks with high error values or few frames
#+BEGIN_SRC python
  .clean_tracks(frames=0, error=0, action='SELECT')
#+END_SRC
** Clear all calculated data
#+BEGIN_SRC python
  .clear_solution()
#+END_SRC
** Clear hide selected tracks
#+BEGIN_SRC python
  .hide_tracks_clear()
#+END_SRC
** Clear tracks after/before current position or clear the whole track
#+BEGIN_SRC python
  .clear_track_path(action='REMAINED', clear_active=False)
#+END_SRC
** Copy color to all selected tracks
#+BEGIN_SRC python
  .track_copy_color()
#+END_SRC
** Copy selected tracks to clipboard
#+BEGIN_SRC python
  .copy_tracks()
#+END_SRC
** Copy tracking settings from active track to default settings
#+BEGIN_SRC python
  .track_settings_as_default()
#+END_SRC
** Create F-Curves for object which will copy object's movement caused by this constraint
#+BEGIN_SRC python
  .constraint_to_fcurve()
#+END_SRC
** Create an Empty object which will be copying movement of active track
#+BEGIN_SRC python
  .track_to_empty()
#+END_SRC
** Create new plane track out of selected point tracks
#+BEGIN_SRC python
  .create_plane_track()
#+END_SRC
** Create vertex cloud using coordinates of reconstructed tracks
#+BEGIN_SRC python
  .bundles_to_mesh()
#+END_SRC
** Delete a keyframe from selected tracks at current frame
#+BEGIN_SRC python
  .keyframe_delete()
#+END_SRC
** Delete curve knots
#+BEGIN_SRC python
  .graph_delete_knot()
#+END_SRC
** Delete marker for current frame from selected tracks
#+BEGIN_SRC python
  .delete_marker()
#+END_SRC
** Delete movie clip proxy files from the hard drive
#+BEGIN_SRC python
  .delete_proxy()
#+END_SRC
** Delete selected curves
#+BEGIN_SRC python
  .graph_delete_curve()
#+END_SRC
** Delete selected tracks
#+BEGIN_SRC python
  .delete_track()
#+END_SRC
** Disable/enable selected markers
#+BEGIN_SRC python
  .disable_markers(action='DISABLE')
#+END_SRC
** Disable/enable selected markers
#+BEGIN_SRC python
  .graph_disable_markers(action='DISABLE')
#+END_SRC
** Hide selected tracks
#+BEGIN_SRC python
  .hide_tracks(unselected=False)
#+END_SRC
** Insert a keyframe to selected tracks at current frame
#+BEGIN_SRC python
  .keyframe_insert()
#+END_SRC
** Interactively change the current frame number
#+BEGIN_SRC python
  .change_frame(frame=0)
#+END_SRC
** Join selected tracks
#+BEGIN_SRC python
  .join_tracks()
#+END_SRC
** Jump to special frame
#+BEGIN_SRC python
  .frame_jump(position='PATHSTART')
#+END_SRC
** Load a sequence of frames or a movie file
#+BEGIN_SRC python
  .open(directory="", files=[], filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Lock/unlock selected tracks
#+BEGIN_SRC python
  .lock_tracks(action='LOCK')
#+END_SRC
** Pan the view
#+BEGIN_SRC python
  .view_pan(offset=(0, 0))
#+END_SRC
** Paste tracks from clipboard
#+BEGIN_SRC python
  .paste_tracks()
#+END_SRC
** Place new marker at specified location
#+BEGIN_SRC python
  .add_marker(location=(0, 0))
#+END_SRC
** Place new marker at the desired (clicked) position
#+BEGIN_SRC python
  .add_marker_at_click()
#+END_SRC
** Prefetch frames from disk for faster playback/tracking
#+BEGIN_SRC python
  .prefetch()
#+END_SRC
** Prepare scene for compositing 3D objects into this footage
#+BEGIN_SRC python
  .setup_tracking_scene()
#+END_SRC
** Rebuild all selected proxies and timecode indices in the background
#+BEGIN_SRC python
  .rebuild_proxy()
#+END_SRC
** Refine selected markers positions by running the tracker from track's reference to current frame
#+BEGIN_SRC python
  .refine_markers(backwards=False)
#+END_SRC
** Reload clip
#+BEGIN_SRC python
  .reload()
#+END_SRC
** Remove object for tracking
#+BEGIN_SRC python
  .tracking_object_remove()
#+END_SRC
** Remove selected track from stabilization
#+BEGIN_SRC python
  .stabilize_2d_remove()
#+END_SRC
** Reset viewable area to show full keyframe range
#+BEGIN_SRC python
  .dopesheet_view_all()
#+END_SRC
** Scroll view so current frame would be centered
#+BEGIN_SRC python
  .graph_center_current_frame()
#+END_SRC
** Select all tracks from specified group
#+BEGIN_SRC python
  .select_grouped(group='ESTIMATED')
#+END_SRC
** Select curve points using border selection
#+BEGIN_SRC python
  .graph_select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Select graph curves
#+BEGIN_SRC python
  .graph_select(location=(0, 0), extend=False)
#+END_SRC
** Select markers using border selection
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Select markers using circle selection
#+BEGIN_SRC python
  .select_circle(x=0, y=0, radius=0, gesture_mode=0)
#+END_SRC
** Select markers using lasso selection
#+BEGIN_SRC python
  .select_lasso(path=[], deselect=False, extend=True)
#+END_SRC
** Select movie tracking channel
#+BEGIN_SRC python
  .dopesheet_select_channel(location=(0, 0), extend=False)
#+END_SRC
** Select track which are used for stabilization
#+BEGIN_SRC python
  .stabilize_2d_select()
#+END_SRC
** Select tracking markers
#+BEGIN_SRC python
  .select(extend=False, location=(0, 0))
#+END_SRC
** Set 2D cursor location
#+BEGIN_SRC python
  .cursor_set(location=(0, 0))
#+END_SRC
** Set active marker as origin by moving camera (or it's parent if present) in 3D space
#+BEGIN_SRC python
  .set_origin(use_median=False)
#+END_SRC
** Set current movie clip as a camera background in 3D view-port (works only when a 3D view-port is visible)
#+BEGIN_SRC python
  .set_viewport_background()
#+END_SRC
** Set direction of scene axis rotating camera (or it's parent if present) and assuming selected track lies on real axis joining it with the origin
#+BEGIN_SRC python
  .set_axis(axis='X')
#+END_SRC
** Set keyframe used by solver
#+BEGIN_SRC python
  .set_solver_keyframe(keyframe='KEYFRAME_A')
#+END_SRC
** Set object solution scale using distance between two selected tracks
#+BEGIN_SRC python
  .set_solution_scale(distance=0)
#+END_SRC
** Set optical center to center of footage
#+BEGIN_SRC python
  .set_center_principal()
#+END_SRC
** Set plane based on 3 selected bundles by moving camera (or it's parent if present) in 3D space
#+BEGIN_SRC python
  .set_plane(plane='FLOOR')
#+END_SRC
** Set scale of scene by scaling camera (or it's parent if present)
#+BEGIN_SRC python
  .set_scale(distance=0)
#+END_SRC
** Set scene's start and end frame to match clip's start frame and length
#+BEGIN_SRC python
  .set_scene_frames()
#+END_SRC
** Set the clip interaction mode
#+BEGIN_SRC python
  .mode_set(mode='TRACKING')
#+END_SRC
** Set the zoom ratio (based on clip size)
#+BEGIN_SRC python
  .view_zoom_ratio(ratio=0)
#+END_SRC
** Slide marker areas
#+BEGIN_SRC python
  .slide_marker(offset=(0, 0))
#+END_SRC
** Slide plane marker areas
#+BEGIN_SRC python
  .slide_plane_marker()
#+END_SRC
** Solve camera motion from tracks
#+BEGIN_SRC python
  .solve_camera()
#+END_SRC
** Toggle clip properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Toggle clip tools panel
#+BEGIN_SRC python
  .tools()
#+END_SRC
** Track selected markers
#+BEGIN_SRC python
  .track_markers(backwards=False, sequence=False, clip="")
#+END_SRC
** Use a 3D mouse device to pan/zoom the view
#+BEGIN_SRC python
  .view_ndof()
#+END_SRC
** Use active track to compensate rotation when doing 2D stabilization
#+BEGIN_SRC python
  .stabilize_2d_set_rotation()
#+END_SRC
** View all curves in editor
#+BEGIN_SRC python
  .graph_view_all()
#+END_SRC
** View all selected elements
#+BEGIN_SRC python
  .view_selected()
#+END_SRC
** View whole image with markers
#+BEGIN_SRC python
  .view_all(fit_view=False)
#+END_SRC
** Zoom in the view
#+BEGIN_SRC python
  .view_zoom_in(location=(0, 0))
#+END_SRC
** Zoom in/out the view
#+BEGIN_SRC python
  .view_zoom(factor=0)
#+END_SRC
** Zoom out the view
#+BEGIN_SRC python
  .view_zoom_out(location=(0, 0))
#+END_SRC
* bpy.ops.cloth
** Add a Cloth Preset
#+BEGIN_SRC python
  .preset_add(remove_active=False, name="")
#+END_SRC
* bpy.ops.console
** Add 4 spaces at line beginning
#+BEGIN_SRC python
  .indent()
#+END_SRC
** Append history at cursor position
#+BEGIN_SRC python
  .history_append(text="", current_character=0, remove_duplicates=False)
#+END_SRC
** Append scrollback text by type
#+BEGIN_SRC python
  .scrollback_append(text="", type='OUTPUT')
#+END_SRC
** Clear text by type
#+BEGIN_SRC python
  .clear(scrollback=True, history=False)
#+END_SRC
** Clear the line and store in history
#+BEGIN_SRC python
  .clear_line()
#+END_SRC
** Copy selected text to clipboard
#+BEGIN_SRC python
  .copy()
#+END_SRC
** Copy the console contents for use in a script
#+BEGIN_SRC python
  .copy_as_script()
#+END_SRC
** Cycle through history
#+BEGIN_SRC python
  .history_cycle(reverse=False)
#+END_SRC
** Delete 4 spaces from line beginning
#+BEGIN_SRC python
  .unindent()
#+END_SRC
** Delete text by cursor position
#+BEGIN_SRC python
  .delete(type='NEXT_CHARACTER')
#+END_SRC
** Evaluate the namespace up until the cursor and give a list of options or complete the name if there is only one
#+BEGIN_SRC python
  .autocomplete()
#+END_SRC
** Execute the current console line as a python expression
#+BEGIN_SRC python
  .execute(interactive=False)
#+END_SRC
** Insert text at cursor position
#+BEGIN_SRC python
  .insert(text="")
#+END_SRC
** Move cursor position
#+BEGIN_SRC python
  .move(type='LINE_BEGIN')
#+END_SRC
** Paste text from clipboard
#+BEGIN_SRC python
  .paste()
#+END_SRC
** Print a message when the terminal initializes
#+BEGIN_SRC python
  .banner()
#+END_SRC
** Set the console selection
#+BEGIN_SRC python
  .select_set()
#+END_SRC
** Set the current language for this console
#+BEGIN_SRC python
  .language(language="")
#+END_SRC
* bpy.ops.constraint
** Add default animation for path used by constraint if it isn't animated already
#+BEGIN_SRC python
  .followpath_path_animate(constraint="", owner='OBJECT', frame_start=1, length=100)
#+END_SRC
** Clear inverse correction for ChildOf constraint
#+BEGIN_SRC python
  .childof_clear_inverse(constraint="", owner='OBJECT')
#+END_SRC
** Clear inverse correction for ObjectSolver constraint
#+BEGIN_SRC python
  .objectsolver_clear_inverse(constraint="", owner='OBJECT')
#+END_SRC
** Move constraint down in constraint stack
#+BEGIN_SRC python
  .move_down(constraint="", owner='OBJECT')
#+END_SRC
** Move constraint up in constraint stack
#+BEGIN_SRC python
  .move_up(constraint="", owner='OBJECT')
#+END_SRC
** Remove constraint from constraint stack
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Reset limiting distance for Limit Distance Constraint
#+BEGIN_SRC python
  .limitdistance_reset(constraint="", owner='OBJECT')
#+END_SRC
** Reset original length of bone for Stretch To Constraint
#+BEGIN_SRC python
  .stretchto_reset(constraint="", owner='OBJECT')
#+END_SRC
** Set inverse correction for ChildOf constraint
#+BEGIN_SRC python
  .childof_set_inverse(constraint="", owner='OBJECT')
#+END_SRC
** Set inverse correction for ObjectSolver constraint
#+BEGIN_SRC python
  .objectsolver_set_inverse(constraint="", owner='OBJECT')
#+END_SRC
* bpy.ops.curve
** (De)select all control points
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** (De)select first of visible part of each NURBS
#+BEGIN_SRC python
  .de_select_first()
#+END_SRC
** (De)select last of visible part of each NURBS
#+BEGIN_SRC python
  .de_select_last()
#+END_SRC
** Add a new control point (linked to only selected end-curve one, if any)
#+BEGIN_SRC python
  .vertex_add(location=(0, 0, 0))
#+END_SRC
** Clear the tilt of selected control points
#+BEGIN_SRC python
  .tilt_clear()
#+END_SRC
** Construct a Bezier Circle
#+BEGIN_SRC python
  .primitive_bezier_circle_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Bezier Curve
#+BEGIN_SRC python
  .primitive_bezier_curve_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs Circle
#+BEGIN_SRC python
  .primitive_nurbs_circle_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs Curve
#+BEGIN_SRC python
  .primitive_nurbs_curve_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Path
#+BEGIN_SRC python
  .primitive_nurbs_path_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Delete selected control points or segments
#+BEGIN_SRC python
  .delete(type='VERT')
#+END_SRC
** Deselect every other vertex
#+BEGIN_SRC python
  .select_nth(nth=2)
#+END_SRC
** Duplicate curve and move
#+BEGIN_SRC python
  .duplicate_move(CURVE_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Duplicate selected control points
#+BEGIN_SRC python
  .duplicate()
#+END_SRC
** Extrude curve and move result
#+BEGIN_SRC python
  .extrude_move(CURVE_OT_extrude={"mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Extrude selected boundary row around pivot point and current view axis
#+BEGIN_SRC python
  .spin(center=(0, 0, 0), axis=(0, 0, 0))
#+END_SRC
** Extrude selected control point(s)
#+BEGIN_SRC python
  .extrude(mode='TRANSLATION')
#+END_SRC
** Flatten angles of selected points
#+BEGIN_SRC python
  .smooth()
#+END_SRC
** Hide (un)selected control points
#+BEGIN_SRC python
  .hide(unselected=False)
#+END_SRC
** Interpolate radii of selected points
#+BEGIN_SRC python
  .smooth_radius()
#+END_SRC
** Interpolate tilt of selected points
#+BEGIN_SRC python
  .smooth_tilt()
#+END_SRC
** Interpolate weight of selected points
#+BEGIN_SRC python
  .smooth_weight()
#+END_SRC
** Join two curves by their selected ends
#+BEGIN_SRC python
  .make_segment()
#+END_SRC
** Make active spline closed/opened loop
#+BEGIN_SRC python
  .cyclic_toggle(direction='CYCLIC_U')
#+END_SRC
** Randomly select some control points
#+BEGIN_SRC python
  .select_random(percent=50, extend=False)
#+END_SRC
** Reduce current selection by deselecting boundary elements
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Select a row of control points including active one
#+BEGIN_SRC python
  .select_row()
#+END_SRC
** Select all control points linked to active one
#+BEGIN_SRC python
  .select_linked()
#+END_SRC
** Select all control points linked to already selected ones
#+BEGIN_SRC python
  .select_linked_pick(deselect=False)
#+END_SRC
** Select control points directly linked to already selected ones
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select control points following already selected ones along the curves
#+BEGIN_SRC python
  .select_next()
#+END_SRC
** Select control points preceding already selected ones along the curves
#+BEGIN_SRC python
  .select_previous()
#+END_SRC
** Separate selected points from connected unselected points into a new object
#+BEGIN_SRC python
  .separate()
#+END_SRC
** Set per-point radius which is used for bevel tapering
#+BEGIN_SRC python
  .radius_set(radius=1)
#+END_SRC
** Set shading to flat
#+BEGIN_SRC python
  .shade_flat()
#+END_SRC
** Set shading to smooth
#+BEGIN_SRC python
  .shade_smooth()
#+END_SRC
** Set softbody goal weight for selected points
#+BEGIN_SRC python
  .spline_weight_set(weight=1)
#+END_SRC
** Set type of active spline
#+BEGIN_SRC python
  .spline_type_set(type='POLY', use_handles=False)
#+END_SRC
** Set type of handles for selected control points
#+BEGIN_SRC python
  .handle_type_set(type='AUTOMATIC')
#+END_SRC
** Show again hidden control points
#+BEGIN_SRC python
  .reveal()
#+END_SRC
** Split off selected points from connected unselected points
#+BEGIN_SRC python
  .split()
#+END_SRC
** Subdivide selected segments
#+BEGIN_SRC python
  .subdivide(number_cuts=1)
#+END_SRC
** Switch direction of selected splines
#+BEGIN_SRC python
  .switch_direction()
#+END_SRC
* bpy.ops.cycles
** Enable nodes on a material, world or lamp
#+BEGIN_SRC python
  .use_shading_nodes()
#+END_SRC
* bpy.ops.dpaint
** Add a new Dynamic Paint surface slot
#+BEGIN_SRC python
  .surface_slot_add()
#+END_SRC
** Add or remove Dynamic Paint output data layer
#+BEGIN_SRC python
  .output_toggle(output='A')
#+END_SRC
** Bake dynamic paint image sequence surface
#+BEGIN_SRC python
  .bake()
#+END_SRC
** Remove the selected surface slot
#+BEGIN_SRC python
  .surface_slot_remove()
#+END_SRC
** Toggle whether given type is active or not
#+BEGIN_SRC python
  .type_toggle(type='CANVAS')
#+END_SRC
* bpy.ops.ed
** Add an undo state (internal use only)
#+BEGIN_SRC python
  .undo_push(message="Add an undo step *function may be moved*")
#+END_SRC
** Redo previous action
#+BEGIN_SRC python
  .redo()
#+END_SRC
** Redo specific action in history
#+BEGIN_SRC python
  .undo_history(item=0)
#+END_SRC
** Undo previous action
#+BEGIN_SRC python
  .undo()
#+END_SRC
* bpy.ops.export_anim
** Save a BVH motion capture file from an armature
#+BEGIN_SRC python
  .bvh(filepath="", check_existing=True, filter_glob="*.bvh", global_scale=1, frame_start=0, frame_end=0, rotate_mode='NATIVE', root_transform_only=False)
#+END_SRC
* bpy.ops.export_mesh
** Export a single object as a Stanford PLY with normals, colors and texture coordinates
#+BEGIN_SRC python
  .ply(filepath="", check_existing=True, filter_glob="*.ply", use_mesh_modifiers=True, use_normals=True, use_uv_coords=True, use_colors=True, axis_forward='Y', axis_up='Z', global_scale=1)
#+END_SRC
** Save STL triangle mesh data from the active object
#+BEGIN_SRC python
  .stl(filepath="", check_existing=True, filter_glob="*.stl", ascii=False, use_mesh_modifiers=True, axis_forward='Y', axis_up='Z', global_scale=1)
#+END_SRC
* bpy.ops.export_scene
** Export selection to Extensible 3D file (.x3d)
#+BEGIN_SRC python
  .x3d(filepath="", check_existing=True, filter_glob="*.x3d", use_selection=False, use_mesh_modifiers=True, use_triangulate=False, use_normals=False, use_compress=False, use_hierarchy=True, name_decorations=True, use_h3d=False, axis_forward='Z', axis_up='Y', global_scale=1, path_mode='AUTO')
#+END_SRC
** Export to 3DS file format (.3ds)
#+BEGIN_SRC python
  .autodesk_3ds(filepath="", check_existing=True, filter_glob="*.3ds", use_selection=False, axis_forward='Y', axis_up='Z')
#+END_SRC
** Save a Wavefront OBJ File
#+BEGIN_SRC python
  .obj(filepath="", check_existing=True, filter_glob="*.obj;*.mtl", use_selection=False, use_animation=False, use_mesh_modifiers=True, use_edges=True, use_smooth_groups=False, use_smooth_groups_bitflags=False, use_normals=False, use_uvs=True, use_materials=True, use_triangles=False, use_nurbs=False, use_vertex_groups=False, use_blen_objects=True, group_by_object=False, group_by_material=False, keep_vertex_order=False, axis_forward='-Z', axis_up='Y', global_scale=1, path_mode='AUTO')
#+END_SRC
** Selection to an ASCII Autodesk FBX
#+BEGIN_SRC python
  .fbx(filepath="", check_existing=True, filter_glob="*.fbx", use_selection=False, global_scale=1, axis_forward='-Z', axis_up='Y', object_types={, 'EMPTY', 'CAMERA', 'LAMP', 'ARMATURE', 'MESH'}, use_mesh_modifiers=True, mesh_smooth_type='FACE', use_mesh_edges=False, use_armature_deform_only=False, use_anim=True, use_anim_action_all=True, use_default_take=True, use_anim_optimize=True, anim_optimize_precision=6, path_mode='AUTO', batch_mode='OFF', use_batch_own_dir=True, use_metadata=True)
#+END_SRC
* bpy.ops.file
** Activate/select file
#+BEGIN_SRC python
  .select(extend=False, fill=False, open=True)
#+END_SRC
** Activate/select the file(s) contained in the border
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Add a bookmark for the selected/active directory
#+BEGIN_SRC python
  .bookmark_add()
#+END_SRC
** Cancel loading of selected file
#+BEGIN_SRC python
  .cancel()
#+END_SRC
** Create a new directory
#+BEGIN_SRC python
  .directory_new(directory="")
#+END_SRC
** Delete selected bookmark
#+BEGIN_SRC python
  .bookmark_delete(index=-1)
#+END_SRC
** Delete selected files
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Enter a directory name
#+BEGIN_SRC python
  .directory()
#+END_SRC
** Execute selected file
#+BEGIN_SRC python
  .execute(need_active=False)
#+END_SRC
** Highlight selected file(s)
#+BEGIN_SRC python
  .highlight()
#+END_SRC
** Increment number in filename
#+BEGIN_SRC python
  .filenum(increment=1)
#+END_SRC
** Make all paths to external files absolute
#+BEGIN_SRC python
  .make_paths_absolute()
#+END_SRC
** Make all paths to external files relative to current .blend
#+BEGIN_SRC python
  .make_paths_relative()
#+END_SRC
** Move to next folder
#+BEGIN_SRC python
  .next()
#+END_SRC
** Move to parent directory
#+BEGIN_SRC python
  .parent()
#+END_SRC
** Move to previous folder
#+BEGIN_SRC python
  .previous()
#+END_SRC
** Pack all used Blender library files into the current .blend
#+BEGIN_SRC python
  .pack_libraries()
#+END_SRC
** Pack all used external files into the .blend
#+BEGIN_SRC python
  .pack_all()
#+END_SRC
** Refresh the file list
#+BEGIN_SRC python
  .refresh()
#+END_SRC
** Rename file or file directory
#+BEGIN_SRC python
  .rename()
#+END_SRC
** Report all missing external files
#+BEGIN_SRC python
  .report_missing_files()
#+END_SRC
** Reset Recent files
#+BEGIN_SRC python
  .reset_recent()
#+END_SRC
** Select a bookmarked directory
#+BEGIN_SRC python
  .select_bookmark(dir="")
#+END_SRC
** Select or deselect all files
#+BEGIN_SRC python
  .select_all_toggle()
#+END_SRC
** Smooth scroll to make editable file visible
#+BEGIN_SRC python
  .smoothscroll()
#+END_SRC
** Toggle bookmarks display
#+BEGIN_SRC python
  .bookmark_toggle()
#+END_SRC
** Toggle hide hidden dot files
#+BEGIN_SRC python
  .hidedot()
#+END_SRC
** Try to find missing external files
#+BEGIN_SRC python
  .find_missing_files(find_all=False, directory="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=False, filemode=9, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Unpack all files packed into this .blend to external ones
#+BEGIN_SRC python
  .unpack_all(method='USE_LOCAL')
#+END_SRC
** Unpack all used Blender library files from this .blend file
#+BEGIN_SRC python
  .unpack_libraries()
#+END_SRC
** Unpack this file to an external file
#+BEGIN_SRC python
  .unpack_item(method='USE_LOCAL', id_name="", id_type=19785)
#+END_SRC
* bpy.ops.fluid
** Add a Fluid Preset
#+BEGIN_SRC python
  .preset_add(remove_active=False, name="")
#+END_SRC
** Bake fluid simulation
#+BEGIN_SRC python
  .bake()
#+END_SRC
* bpy.ops.font
** Add a new text box
#+BEGIN_SRC python
  .textbox_add()
#+END_SRC
** Change font character code
#+BEGIN_SRC python
  .change_character(delta=1)
#+END_SRC
** Change font spacing
#+BEGIN_SRC python
  .change_spacing(delta=1)
#+END_SRC
** Copy selected text to clipboard
#+BEGIN_SRC python
  .text_copy()
#+END_SRC
** Cut selected text to clipboard
#+BEGIN_SRC python
  .text_cut()
#+END_SRC
** Delete text by cursor position
#+BEGIN_SRC python
  .delete(type='ALL')
#+END_SRC
** Insert line break at cursor position
#+BEGIN_SRC python
  .line_break()
#+END_SRC
** Insert placeholder text
#+BEGIN_SRC python
  .insert_lorem()
#+END_SRC
** Insert text at cursor position
#+BEGIN_SRC python
  .text_insert(text="", accent=False)
#+END_SRC
** Load a new font from a file
#+BEGIN_SRC python
  .open(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=True, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Move cursor to position type
#+BEGIN_SRC python
  .move(type='LINE_BEGIN')
#+END_SRC
** Move the cursor while selecting
#+BEGIN_SRC python
  .move_select(type='LINE_BEGIN')
#+END_SRC
** Paste contents from file
#+BEGIN_SRC python
  .file_paste(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=True, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Paste text from clipboard
#+BEGIN_SRC python
  .text_paste()
#+END_SRC
** Remove the textbox
#+BEGIN_SRC python
  .textbox_remove(index=0)
#+END_SRC
** Set font case
#+BEGIN_SRC python
  .case_set(case='LOWER')
#+END_SRC
** Set font style
#+BEGIN_SRC python
  .style_set(style='BOLD', clear=False)
#+END_SRC
** Toggle font case
#+BEGIN_SRC python
  .case_toggle()
#+END_SRC
** Toggle font style
#+BEGIN_SRC python
  .style_toggle(style='BOLD')
#+END_SRC
** Unlink active font data block
#+BEGIN_SRC python
  .unlink()
#+END_SRC
* bpy.ops.gpencil
** Add new Grease Pencil datablock
#+BEGIN_SRC python
  .data_add()
#+END_SRC
** Add new Grease Pencil layer for the active Grease Pencil datablock
#+BEGIN_SRC python
  .layer_add()
#+END_SRC
** Convert the active Grease Pencil layer to a new Curve Object
#+BEGIN_SRC python
  .convert(type='PATH', use_normalize_weights=True, radius_multiplier=1, use_link_strokes=True, timing_mode='<UNKNOWN ENUM>', frame_range=100, start_frame=1, use_realtime=False, end_frame=250, gap_duration=0, gap_randomness=0, seed=0, use_timing_data=False)
#+END_SRC
** Delete the active frame for the active Grease Pencil datablock
#+BEGIN_SRC python
  .active_frame_delete()
#+END_SRC
** Make annotations on the active data
#+BEGIN_SRC python
  .draw(mode='DRAW', stroke=[])
#+END_SRC
** Unlink active Grease Pencil datablock
#+BEGIN_SRC python
  .data_unlink()
#+END_SRC
* bpy.ops.graph
** Add F-Modifiers to the selected F-Curves
#+BEGIN_SRC python
  .fmodifier_add(type='NULL', only_active=True)
#+END_SRC
** Add copied F-Modifiers to the selected F-Curves
#+BEGIN_SRC python
  .fmodifier_paste()
#+END_SRC
** Add keyframes on every frame between the selected keyframes
#+BEGIN_SRC python
  .sample()
#+END_SRC
** Apply weighted moving means to make selected F-Curves less bumpy
#+BEGIN_SRC python
  .smooth()
#+END_SRC
** Automatically set Preview Range based on range of keyframes
#+BEGIN_SRC python
  .previewrange_set()
#+END_SRC
** Bake selected F-Curves to a set of sampled points defining a similar curve
#+BEGIN_SRC python
  .bake()
#+END_SRC
** Bakes a sound wave to selected F-Curves
#+BEGIN_SRC python
  .sound_bake(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY', low=0, high=100000, attack=0.005, release=0.2, threshold=0, use_accumulate=False, use_additive=False, use_square=False, sthreshold=0.1)
#+END_SRC
** Clear F-Curve snapshots (Ghosts) for active Graph Editor
#+BEGIN_SRC python
  .ghost_curves_clear()
#+END_SRC
** Copy selected keyframes to the copy/paste buffer
#+BEGIN_SRC python
  .copy()
#+END_SRC
** Copy the F-Modifier(s) of the active F-Curve
#+BEGIN_SRC python
  .fmodifier_copy()
#+END_SRC
** Create snapshot (Ghosts) of selected F-Curves as background aid for active Graph Editor
#+BEGIN_SRC python
  .ghost_curves_create()
#+END_SRC
** Deselect keyframes on ends of selection islands
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Fix large jumps and flips in the selected Euler Rotation F-Curves arising from rotation values being clipped when baking physics
#+BEGIN_SRC python
  .euler_filter()
#+END_SRC
** Flip selected keyframes over the selected mirror line
#+BEGIN_SRC python
  .mirror(type='CFRA')
#+END_SRC
** Insert keyframes for the specified channels
#+BEGIN_SRC python
  .keyframe_insert(type='ALL')
#+END_SRC
** Insert new keyframe at the cursor position for the active F-Curve
#+BEGIN_SRC python
  .click_insert(frame=1, value=1)
#+END_SRC
** Interactively set the current frame number and value cursor
#+BEGIN_SRC python
  .cursor_set(frame=0, value=0)
#+END_SRC
** Make a copy of all selected keyframes
#+BEGIN_SRC python
  .duplicate(mode='TRANSLATION')
#+END_SRC
** Make a copy of all selected keyframes and move them
#+BEGIN_SRC python
  .duplicate_move(GRAPH_OT_duplicate={"mode":'TRANSLATION'}, TRANSFORM_OT_transform={"mode":'TRANSLATION', "value":(0, 0, 0, 0), "axis":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False})
#+END_SRC
** Paste keyframes from copy/paste buffer for the selected channels, starting on the current frame
#+BEGIN_SRC python
  .paste(offset='START', merge='MIX')
#+END_SRC
** Place the cursor on the midpoint of selected keyframes
#+BEGIN_SRC python
  .frame_jump()
#+END_SRC
** Remove all selected keyframes
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Reset viewable area to show full keyframe range
#+BEGIN_SRC python
  .view_all(include_handles=True)
#+END_SRC
** Reset viewable area to show selected keyframe range
#+BEGIN_SRC python
  .view_selected(include_handles=True)
#+END_SRC
** Select all keyframes on the specified frame(s)
#+BEGIN_SRC python
  .select_column(mode='KEYS')
#+END_SRC
** Select all keyframes within the specified region
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, axis_range=False, include_handles=False)
#+END_SRC
** Select keyframes beside already selected ones
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select keyframes by clicking on them
#+BEGIN_SRC python
  .clickselect(extend=False, column=False, curves=False)
#+END_SRC
** Select keyframes occurring in the same F-Curves as selected ones
#+BEGIN_SRC python
  .select_linked()
#+END_SRC
** Select keyframes to the left or the right of the current frame
#+BEGIN_SRC python
  .select_leftright(mode='CHECK', extend=False)
#+END_SRC
** Set extrapolation mode for selected F-Curves
#+BEGIN_SRC python
  .extrapolation_type(type='CONSTANT')
#+END_SRC
** Set interpolation mode for the F-Curve segments starting from the selected keyframes
#+BEGIN_SRC python
  .interpolation_type(type='CONSTANT')
#+END_SRC
** Set type of handle for selected keyframes
#+BEGIN_SRC python
  .handle_type(type='FREE')
#+END_SRC
** Simplify F-Curves by removing closely spaced keyframes
#+BEGIN_SRC python
  .clean(threshold=0.001)
#+END_SRC
** Snap selected keyframes to the chosen times/values
#+BEGIN_SRC python
  .snap(type='CFRA')
#+END_SRC
** Toggle display properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Toggle selection of all keyframes
#+BEGIN_SRC python
  .select_all_toggle(invert=False)
#+END_SRC
* bpy.ops.group
** Add the object to an object group that contains the active object
#+BEGIN_SRC python
  .objects_add_active(group='<UNKNOWN ENUM>')
#+END_SRC
** Create an object group from selected objects
#+BEGIN_SRC python
  .create(name="Group")
#+END_SRC
** Remove selected objects from a group
#+BEGIN_SRC python
  .objects_remove(group='<UNKNOWN ENUM>')
#+END_SRC
** Remove selected objects from all groups
#+BEGIN_SRC python
  .objects_remove_all()
#+END_SRC
** Remove the object from an object group that contains the active object
#+BEGIN_SRC python
  .objects_remove_active()
#+END_SRC
* bpy.ops.image
** Create a new image
#+BEGIN_SRC python
  .new(name="Untitled", width=1024, height=1024, color=(0, 0, 0, 1), alpha=True, generated_type='BLANK', float=False)
#+END_SRC
** Cycle through all non-void render slots
#+BEGIN_SRC python
  .cycle_render_slot(reverse=False)
#+END_SRC
** Edit a snapshot of the view-port in an external image editor
#+BEGIN_SRC python
  .project_edit()
#+END_SRC
** Edit image in an external application
#+BEGIN_SRC python
  .external_edit(filepath="")
#+END_SRC
** Invert image's channels
#+BEGIN_SRC python
  .invert(invert_r=False, invert_g=False, invert_b=False, invert_a=False)
#+END_SRC
** Open image
#+BEGIN_SRC python
  .open(filepath="", filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Pack an image as embedded data into the .blend file
#+BEGIN_SRC python
  .pack(as_png=False)
#+END_SRC
** Pan the view
#+BEGIN_SRC python
  .view_pan(offset=(0, 0))
#+END_SRC
** Project edited image back onto the object
#+BEGIN_SRC python
  .project_apply()
#+END_SRC
** Reload current image from disk
#+BEGIN_SRC python
  .reload()
#+END_SRC
** Replace current image by another one from disk
#+BEGIN_SRC python
  .replace(filepath="", filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Sample a line and show it in Scope panels
#+BEGIN_SRC python
  .sample_line(xstart=0, xend=0, ystart=0, yend=0, cursor=1002)
#+END_SRC
** Save a sequence of images
#+BEGIN_SRC python
  .save_sequence()
#+END_SRC
** Save all modified textures
#+BEGIN_SRC python
  .save_dirty()
#+END_SRC
** Save an image packed in the .blend file to disk
#+BEGIN_SRC python
  .unpack(method='USE_LOCAL', id="")
#+END_SRC
** Save the image with another name and/or settings
#+BEGIN_SRC python
  .save_as(save_as_render=False, copy=False, filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Save the image with current name and settings
#+BEGIN_SRC python
  .save()
#+END_SRC
** Set black point or white point for curves
#+BEGIN_SRC python
  .curves_point_set(point='BLACK_POINT')
#+END_SRC
** Set image's user's length to the one of this video
#+BEGIN_SRC python
  .match_movie_length()
#+END_SRC
** Set zoom ratio of the view
#+BEGIN_SRC python
  .view_zoom_ratio(ratio=0)
#+END_SRC
** Toggle display properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Toggle display scopes panel
#+BEGIN_SRC python
  .scopes()
#+END_SRC
** Use a 3D mouse device to pan/zoom the view
#+BEGIN_SRC python
  .view_ndof()
#+END_SRC
** Use mouse to sample a color in current image
#+BEGIN_SRC python
  .sample()
#+END_SRC
** View all selected UVs
#+BEGIN_SRC python
  .view_selected()
#+END_SRC
** View the entire image
#+BEGIN_SRC python
  .view_all(fit_view=False)
#+END_SRC
** Zoom in the image (centered around 2D cursor)
#+BEGIN_SRC python
  .view_zoom_in(location=(0, 0))
#+END_SRC
** Zoom in/out the image
#+BEGIN_SRC python
  .view_zoom(factor=0)
#+END_SRC
** Zoom out the image (centered around 2D cursor)
#+BEGIN_SRC python
  .view_zoom_out(location=(0, 0))
#+END_SRC
* bpy.ops.import_anim
** Load a BVH motion capture file
#+BEGIN_SRC python
  .bvh(filepath="", filter_glob="*.bvh", target='ARMATURE', global_scale=1, frame_start=1, use_fps_scale=False, use_cyclic=False, rotate_mode='NATIVE', axis_forward='-Z', axis_up='Y')
#+END_SRC
* bpy.ops.import_curve
** Load a SVG file
#+BEGIN_SRC python
  .svg(filepath="", filter_glob="*.svg")
#+END_SRC
* bpy.ops.import_mesh
** Load STL triangle mesh data
#+BEGIN_SRC python
  .stl(filepath="", filter_glob="*.stl", files=[], directory="")
#+END_SRC
** Load a PLY geometry file
#+BEGIN_SRC python
  .ply(filepath="", files=[], directory="", filter_glob="*.ply")
#+END_SRC
* bpy.ops.import_scene
** Import an X3D or VRML2 file
#+BEGIN_SRC python
  .x3d(filepath="", filter_glob="*.x3d;*.wrl", axis_forward='Z', axis_up='Y')
#+END_SRC
** Import from 3DS file format (.3ds)
#+BEGIN_SRC python
  .autodesk_3ds(filepath="", filter_glob="*.3ds", constrain_size=10, use_image_search=True, use_apply_transform=True, axis_forward='Y', axis_up='Z')
#+END_SRC
** Load a FBX geometry file
#+BEGIN_SRC python
  .fbx(filepath="", directory="", filter_glob="*.fbx", use_image_search=True, use_alpha_decals=False, decal_offset=0, axis_forward='-Z', axis_up='Y', global_scale=1)
#+END_SRC
** Load a Wavefront OBJ File
#+BEGIN_SRC python
  .obj(filepath="", filter_glob="*.obj;*.mtl", use_ngons=True, use_edges=True, use_smooth_groups=True, use_split_objects=True, use_split_groups=True, use_groups_as_vgroups=False, use_image_search=True, split_mode='ON', global_clamp_size=0, axis_forward='-Z', axis_up='Y')
#+END_SRC
* bpy.ops.info
** Copy selected reports to Clipboard
#+BEGIN_SRC python
  .report_copy()
#+END_SRC
** Delete selected reports
#+BEGIN_SRC python
  .report_delete()
#+END_SRC
** Replay selected reports
#+BEGIN_SRC python
  .report_replay()
#+END_SRC
** Select or deselect all reports
#+BEGIN_SRC python
  .select_all_toggle()
#+END_SRC
** Select reports by index
#+BEGIN_SRC python
  .select_pick(report_index=0)
#+END_SRC
** Toggle border selection
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Update the display of reports in Blender UI (internal use)
#+BEGIN_SRC python
  .reports_display_update()
#+END_SRC
* bpy.ops.lamp
** Add a Sky & Atmosphere Preset
#+BEGIN_SRC python
  .sunsky_preset_add(remove_active=False, name="")
#+END_SRC
* bpy.ops.lattice
** Change selection of all UVW control points
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Deselect vertices at the boundary of each selection region
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Mirror all control points without inverting the lattice deform
#+BEGIN_SRC python
  .flip(axis='U')
#+END_SRC
** Randomly select UVW control points
#+BEGIN_SRC python
  .select_random(percent=50, extend=False)
#+END_SRC
** Select vertex directly linked to already selected ones
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select vertices without a group
#+BEGIN_SRC python
  .select_ungrouped(extend=False)
#+END_SRC
** Set UVW control points a uniform distance apart
#+BEGIN_SRC python
  .make_regular()
#+END_SRC
* bpy.ops.logic
** Add a controller to the active object
#+BEGIN_SRC python
  .controller_add(type='LOGIC_AND', name="", object="")
#+END_SRC
** Add a sensor to the active object
#+BEGIN_SRC python
  .sensor_add(type='ALWAYS', name="", object="")
#+END_SRC
** Add an actuator to the active object
#+BEGIN_SRC python
  .actuator_add(type='MOTION', name="", object="")
#+END_SRC
** Convert old texface settings into material. It may create new materials if needed
#+BEGIN_SRC python
  .texface_convert()
#+END_SRC
** Move Actuator
#+BEGIN_SRC python
  .actuator_move(actuator="", object="", direction='UP')
#+END_SRC
** Move Controller
#+BEGIN_SRC python
  .controller_move(controller="", object="", direction='UP')
#+END_SRC
** Move Sensor
#+BEGIN_SRC python
  .sensor_move(sensor="", object="", direction='UP')
#+END_SRC
** Remove a controller from the active object
#+BEGIN_SRC python
  .controller_remove(controller="", object="")
#+END_SRC
** Remove a sensor from the active object
#+BEGIN_SRC python
  .sensor_remove(sensor="", object="")
#+END_SRC
** Remove an actuator from the active object
#+BEGIN_SRC python
  .actuator_remove(actuator="", object="")
#+END_SRC
** Remove logic brick connections
#+BEGIN_SRC python
  .links_cut(path=[], cursor=9)
#+END_SRC
** Resize view so you can see all logic bricks
#+BEGIN_SRC python
  .view_all()
#+END_SRC
** Toggle display properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
* bpy.ops.marker
** Add a new time marker
#+BEGIN_SRC python
  .add()
#+END_SRC
** Bind the active camera to selected markers(s)
#+BEGIN_SRC python
  .camera_bind()
#+END_SRC
** Change selection of all time markers
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Copy selected markers to another scene
#+BEGIN_SRC python
  .make_links_scene(scene='Scene')
#+END_SRC
** Delete selected time marker(s)
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Duplicate selected time marker(s)
#+BEGIN_SRC python
  .duplicate(frames=0)
#+END_SRC
** Move selected time marker(s)
#+BEGIN_SRC python
  .move(frames=0)
#+END_SRC
** Rename first selected time marker
#+BEGIN_SRC python
  .rename(name="RenamedMarker")
#+END_SRC
** Select all time markers using border selection
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Select time marker(s)
#+BEGIN_SRC python
  .select(extend=False, camera=False)
#+END_SRC
* bpy.ops.mask
** (De)select all points linked to the curve under the mouse cursor
#+BEGIN_SRC python
  .select_linked_pick(deselect=False)
#+END_SRC
** Add new circle-shaped spline
#+BEGIN_SRC python
  .primitive_circle_add(size=100, location=(0, 0))
#+END_SRC
** Add new mask layer for masking
#+BEGIN_SRC python
  .layer_new(name="")
#+END_SRC
** Add new square-shaped spline
#+BEGIN_SRC python
  .primitive_square_add(size=100, location=(0, 0))
#+END_SRC
** Add new vertex and slide it
#+BEGIN_SRC python
  .add_vertex_slide(MASK_OT_add_vertex={"location":(0, 0)}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Add new vertex to feather and slide it
#+BEGIN_SRC python
  .add_feather_vertex_slide(MASK_OT_add_feather_vertex={"location":(0, 0)}, MASK_OT_slide_point={"slide_feather":False})
#+END_SRC
** Add vertex to active spline
#+BEGIN_SRC python
  .add_vertex(location=(0, 0))
#+END_SRC
** Add vertex to feather
#+BEGIN_SRC python
  .add_feather_vertex(location=(0, 0))
#+END_SRC
** Change selection of all curve points
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Clear the mask's parenting
#+BEGIN_SRC python
  .parent_clear()
#+END_SRC
** Create new mask
#+BEGIN_SRC python
  .new(name="")
#+END_SRC
** Delete selected control points or splines
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Deselect spline points at the boundary of each selection region
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Duplicate mask and move
#+BEGIN_SRC python
  .duplicate_move(MASK_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Duplicate selected control points and segments between them
#+BEGIN_SRC python
  .duplicate()
#+END_SRC
** Hide the layer by setting the hide flag
#+BEGIN_SRC python
  .hide_view_set(unselected=False)
#+END_SRC
** Move the active layer up/down in the list
#+BEGIN_SRC python
  .layer_move(direction='UP')
#+END_SRC
** Re-calculate the direction of selected handles
#+BEGIN_SRC python
  .normals_make_consistent()
#+END_SRC
** Recalculate animation data on selected points for frames selected in the dopesheet
#+BEGIN_SRC python
  .shape_key_rekey(location=True, feather=True)
#+END_SRC
** Remove mask layer
#+BEGIN_SRC python
  .layer_remove()
#+END_SRC
** Reset feather weights on all selected points animation values
#+BEGIN_SRC python
  .shape_key_feather_reset()
#+END_SRC
** Reset the feather weight to zero
#+BEGIN_SRC python
  .feather_weight_clear()
#+END_SRC
** Reveal the layer by setting the hide flag
#+BEGIN_SRC python
  .hide_view_clear()
#+END_SRC
** Select all curve points linked to already selected ones
#+BEGIN_SRC python
  .select_linked()
#+END_SRC
** Select curve points using border selection
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Select curve points using circle selection
#+BEGIN_SRC python
  .select_circle(x=0, y=0, radius=0, gesture_mode=0)
#+END_SRC
** Select curve points using lasso selection
#+BEGIN_SRC python
  .select_lasso(path=[], deselect=False, extend=True)
#+END_SRC
** Select more spline points connected to initial selection
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select spline points
#+BEGIN_SRC python
  .select(extend=False, deselect=False, toggle=False, location=(0, 0))
#+END_SRC
** Set the mask's parenting
#+BEGIN_SRC python
  .parent_set()
#+END_SRC
** Set type of handles for selected control points
#+BEGIN_SRC python
  .handle_type_set(type='AUTO')
#+END_SRC
** Slide control points
#+BEGIN_SRC python
  .slide_point(slide_feather=False)
#+END_SRC
** Switch direction of selected splines
#+BEGIN_SRC python
  .switch_direction()
#+END_SRC
** Toggle cyclic for selected splines
#+BEGIN_SRC python
  .cyclic_toggle()
#+END_SRC
** shape_key_clear
#+BEGIN_SRC python
  .shape_key_clear()
#+END_SRC
** shape_key_insert
#+BEGIN_SRC python
  .shape_key_insert()
#+END_SRC
* bpy.ops.material
** Add a Subsurface Scattering Preset
#+BEGIN_SRC python
  .sss_preset_add(remove_active=False, name="")
#+END_SRC
** Add a new material
#+BEGIN_SRC python
  .new()
#+END_SRC
** Copy the material settings and nodes
#+BEGIN_SRC python
  .copy()
#+END_SRC
** Paste the material settings and nodes
#+BEGIN_SRC python
  .paste()
#+END_SRC
* bpy.ops.mball
** Change selection of all meta elements
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Delete selected metaelement(s)
#+BEGIN_SRC python
  .delete_metaelems()
#+END_SRC
** Duplicate selected metaelement(s)
#+BEGIN_SRC python
  .duplicate_metaelems()
#+END_SRC
** Hide (un)selected metaelement(s)
#+BEGIN_SRC python
  .hide_metaelems(unselected=False)
#+END_SRC
** Make copies of the selected bones within the same armature and move them
#+BEGIN_SRC python
  .duplicate_move(MBALL_OT_duplicate_metaelems={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Randomly select metaelements
#+BEGIN_SRC python
  .select_random_metaelems(percent=0.5)
#+END_SRC
** Reveal all hidden metaelements
#+BEGIN_SRC python
  .reveal_metaelems()
#+END_SRC
** Select similar metaballs by property types
#+BEGIN_SRC python
  .select_similar(type='TYPE', threshold=0.1)
#+END_SRC
* bpy.ops.mesh
** (De)select all vertices linked to the edge under the mouse cursor
#+BEGIN_SRC python
  .select_linked_pick(deselect=False, limit=False)
#+END_SRC
** (De)select all vertices, edges or faces
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** (Un)mark selected edges as Freestyle feature edges
#+BEGIN_SRC python
  .mark_freestyle_edge(clear=False)
#+END_SRC
** (Un)mark selected edges as a seam
#+BEGIN_SRC python
  .mark_seam(clear=False)
#+END_SRC
** (Un)mark selected edges as sharp
#+BEGIN_SRC python
  .mark_sharp(clear=False)
#+END_SRC
** (Un)mark selected faces for exclusion from Freestyle feature edge detection
#+BEGIN_SRC python
  .mark_freestyle_face(clear=False)
#+END_SRC
** Add UV Map
#+BEGIN_SRC python
  .uv_texture_add()
#+END_SRC
** Add a new index and assign it to selected faces
#+BEGIN_SRC python
  .navmesh_face_add()
#+END_SRC
** Add a new loop between existing loops
#+BEGIN_SRC python
  .loopcut(number_cuts=1, smoothness=0, falloff='ROOT', edge_index=-1, mesh_select_mode_init=(False, False, False))
#+END_SRC
** Add a torus mesh
#+BEGIN_SRC python
  .primitive_torus_add(rotation=(0, 0, 0), location=(0, 0, 0), view_align=False, major_segments=48, minor_segments=12, mode='MAJOR_MINOR', major_radius=1, minor_radius=0.25, abso_major_rad=1.25, abso_minor_rad=0.75)
#+END_SRC
** Add an edge or face to selected
#+BEGIN_SRC python
  .edge_face_add()
#+END_SRC
** Add vertex color layer
#+BEGIN_SRC python
  .vertex_color_add()
#+END_SRC
** Apply selected vertex locations to all other shape keys
#+BEGIN_SRC python
  .shape_propagate_to_all()
#+END_SRC
** Assign Image to active UV Map, or create an UV Map
#+BEGIN_SRC python
  .drop_named_image(name="Image", filepath="Path")
#+END_SRC
** Assign a new index to every face
#+BEGIN_SRC python
  .navmesh_reset()
#+END_SRC
** Blend in shape from a shape key
#+BEGIN_SRC python
  .blend_from_shape(shape='<UNKNOWN ENUM>', blend=1, add=True)
#+END_SRC
** Change selection mode
#+BEGIN_SRC python
  .select_mode(use_extend=False, use_expand=False, type='VERT', action='TOGGLE')
#+END_SRC
** Clear vertex sculpt masking data from the mesh
#+BEGIN_SRC python
  .customdata_clear_mask()
#+END_SRC
** Clear vertex skin layer
#+BEGIN_SRC python
  .customdata_clear_skin()
#+END_SRC
** Collapse selected edges
#+BEGIN_SRC python
  .edge_collapse()
#+END_SRC
** Connect 2 vertices of a face by an edge, splitting the face in two
#+BEGIN_SRC python
  .vert_connect()
#+END_SRC
** Construct a Suzanne mesh
#+BEGIN_SRC python
  .primitive_monkey_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a UV sphere mesh
#+BEGIN_SRC python
  .primitive_uv_sphere_add(segments=32, ring_count=16, size=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a circle mesh
#+BEGIN_SRC python
  .primitive_circle_add(vertices=32, radius=1, fill_type='NOTHING', view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a conic mesh
#+BEGIN_SRC python
  .primitive_cone_add(vertices=32, radius1=1, radius2=0, depth=2, end_fill_type='NGON', view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a cube mesh
#+BEGIN_SRC python
  .primitive_cube_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a cylinder mesh
#+BEGIN_SRC python
  .primitive_cylinder_add(vertices=32, radius=1, depth=2, end_fill_type='NGON', view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a filled planar mesh with 4 vertices
#+BEGIN_SRC python
  .primitive_plane_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a grid mesh
#+BEGIN_SRC python
  .primitive_grid_add(x_subdivisions=10, y_subdivisions=10, radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct an Icosphere mesh
#+BEGIN_SRC python
  .primitive_ico_sphere_add(subdivisions=2, size=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Copy mirror UV coordinates on the X axis based on a mirrored mesh
#+BEGIN_SRC python
  .faces_mirror_uv(direction='POSITIVE', precision=3)
#+END_SRC
** Copy the index from the active face
#+BEGIN_SRC python
  .navmesh_face_copy()
#+END_SRC
** Create a solid skin by extruding, compensating for sharp angles
#+BEGIN_SRC python
  .solidify(thickness=0.01)
#+END_SRC
** Create a solid wire-frame from faces
#+BEGIN_SRC python
  .wireframe(use_boundary=True, use_even_offset=True, use_relative_offset=False, use_crease=False, thickness=0.01, use_replace=True)
#+END_SRC
** Create navigation mesh for selected objects
#+BEGIN_SRC python
  .navmesh_make()
#+END_SRC
** Cut geometry along a plane (click-drag to define plane)
#+BEGIN_SRC python
  .bisect(plane_co=(0, 0, 0), plane_no=(0, 0, 0), use_fill=False, clear_inner=False, clear_outer=False, threshold=0.0001, xstart=0, xend=0, ystart=0, yend=0, cursor=1002)
#+END_SRC
** Cut mesh loop and slide it
#+BEGIN_SRC python
  .loopcut_slide(MESH_OT_loopcut={"number_cuts":1, "smoothness":0, "falloff":'ROOT', "edge_index":-1, "mesh_select_mode_init":(False, False, False)}, TRANSFORM_OT_edge_slide={"value":0, "mirror":False, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "correct_uv":False, "release_confirm":False})
#+END_SRC
** Cut new topology
#+BEGIN_SRC python
  .knife_tool(use_occlude_geometry=True, only_selected=False)
#+END_SRC
** Delete an edge loop by merging the faces on each side
#+BEGIN_SRC python
  .delete_edgeloop(use_face_split=True)
#+END_SRC
** Delete selected vertices, edges or faces
#+BEGIN_SRC python
  .delete(type='VERT')
#+END_SRC
** Deselect every Nth element starting from the active vertex, edge or face
#+BEGIN_SRC python
  .select_nth(nth=2, offset=0)
#+END_SRC
** Deselect vertices, edges or faces at the boundary of each selection region
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Disconnect vertex or edges from connected geometry
#+BEGIN_SRC python
  .rip(mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, release_confirm=False, use_fill=False)
#+END_SRC
** Display faces flat
#+BEGIN_SRC python
  .faces_shade_flat()
#+END_SRC
** Display faces smooth (using vertex normals)
#+BEGIN_SRC python
  .faces_shade_smooth()
#+END_SRC
** Dissolve edges, merging faces
#+BEGIN_SRC python
  .dissolve_edges(use_verts=False, use_face_split=False)
#+END_SRC
** Dissolve faces
#+BEGIN_SRC python
  .dissolve_faces(use_verts=False)
#+END_SRC
** Dissolve geometry based on the selection mode
#+BEGIN_SRC python
  .dissolve_mode(use_verts=False, use_face_split=False)
#+END_SRC
** Dissolve selected edges and verts, limited by the angle of surrounding geometry
#+BEGIN_SRC python
  .dissolve_limited(angle_limit=0.0872665, use_dissolve_boundaries=False, delimit=set())
#+END_SRC
** Dissolve verts, merge edges and faces
#+BEGIN_SRC python
  .dissolve_verts(use_face_split=False)
#+END_SRC
** Duplicate and extrude selected vertices, edges or faces towards the mouse cursor
#+BEGIN_SRC python
  .dupli_extrude_cursor(rotate_source=True)
#+END_SRC
** Duplicate mesh and move
#+BEGIN_SRC python
  .duplicate_move(MESH_OT_duplicate={"mode":1}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Duplicate selected vertices, edges or faces
#+BEGIN_SRC python
  .duplicate(mode=1)
#+END_SRC
** Edge Bevel
#+BEGIN_SRC python
  .bevel(offset=0, segments=1, vertex_only=False)
#+END_SRC
** Enclose selected vertices in a convex polyhedron
#+BEGIN_SRC python
  .convex_hull(delete_unused=True, use_existing_faces=True, make_holes=False, join_triangles=True, limit=0.698132, uvs=False, vcols=False, sharp=False, materials=False)
#+END_SRC
** Enforce symmetry (both form and topological) across an axis
#+BEGIN_SRC python
  .symmetrize(direction='NEGATIVE_X', threshold=0.0001)
#+END_SRC
** Extrude edges and move result
#+BEGIN_SRC python
  .extrude_edges_move(MESH_OT_extrude_edges_indiv={"mirror":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Extrude faces and move result
#+BEGIN_SRC python
  .extrude_faces_move(MESH_OT_extrude_faces_indiv={"mirror":False}, TRANSFORM_OT_shrink_fatten={"value":0, "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False})
#+END_SRC
** Extrude individual edges only
#+BEGIN_SRC python
  .extrude_edges_indiv(mirror=False)
#+END_SRC
** Extrude individual faces only
#+BEGIN_SRC python
  .extrude_faces_indiv(mirror=False)
#+END_SRC
** Extrude individual vertices only
#+BEGIN_SRC python
  .extrude_verts_indiv(mirror=False)
#+END_SRC
** Extrude region and move result
#+BEGIN_SRC python
  .extrude_region_move(MESH_OT_extrude_region={"mirror":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Extrude region and move result
#+BEGIN_SRC python
  .extrude_region_shrink_fatten(MESH_OT_extrude_region={"mirror":False}, TRANSFORM_OT_shrink_fatten={"value":0, "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False})
#+END_SRC
** Extrude region of faces
#+BEGIN_SRC python
  .extrude_region(mirror=False)
#+END_SRC
** Extrude selected vertices in a circle around the cursor in indicated viewport
#+BEGIN_SRC python
  .spin(steps=9, dupli=False, angle=1.5708, center=(0, 0, 0), axis=(0, 0, 0))
#+END_SRC
** Extrude selected vertices in screw-shaped rotation around the cursor in indicated viewport
#+BEGIN_SRC python
  .screw(steps=9, turns=1, center=(0, 0, 0), axis=(0, 0, 0))
#+END_SRC
** Extrude selected vertices, edges or faces repeatedly
#+BEGIN_SRC python
  .extrude_repeat(offset=2, steps=10)
#+END_SRC
** Extrude vertices and move result
#+BEGIN_SRC python
  .extrude_vertices_move(MESH_OT_extrude_verts_indiv={"mirror":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Fill a selected edge loop with faces
#+BEGIN_SRC python
  .fill(use_beauty=True)
#+END_SRC
** Fill grid from two loops
#+BEGIN_SRC python
  .fill_grid(span=1, offset=0, use_interp_simple=False)
#+END_SRC
** Fill in holes (boundary edge loops)
#+BEGIN_SRC python
  .fill_holes(sides=4)
#+END_SRC
** Flatten angles of selected vertices
#+BEGIN_SRC python
  .vertices_smooth(repeat=1, xaxis=True, yaxis=True, zaxis=True)
#+END_SRC
** Flip direction of UV coordinates inside faces
#+BEGIN_SRC python
  .uvs_reverse()
#+END_SRC
** Flip direction of vertex colors inside faces
#+BEGIN_SRC python
  .colors_reverse()
#+END_SRC
** Flip the direction of selected faces' normals (and of their vertices)
#+BEGIN_SRC python
  .flip_normals()
#+END_SRC
** Hide (un)selected vertices, edges or faces
#+BEGIN_SRC python
  .hide(unselected=False)
#+END_SRC
** Inset new faces into selected faces
#+BEGIN_SRC python
  .inset(use_boundary=True, use_even_offset=True, use_relative_offset=False, thickness=0.01, depth=0, use_outset=False, use_select_inset=True, use_individual=False, use_interpolate=True)
#+END_SRC
** Join triangles into quads
#+BEGIN_SRC python
  .tris_convert_to_quads(limit=0.698132, uvs=False, vcols=False, sharp=False, materials=False)
#+END_SRC
** Laplacian smooth of selected vertices
#+BEGIN_SRC python
  .vertices_smooth_laplacian(repeat=1, lambda_factor=5e-05, lambda_border=5e-05, use_x=True, use_y=True, use_z=True, preserve_volume=True)
#+END_SRC
** Make face and vertex normals point either outside or inside the mesh
#+BEGIN_SRC python
  .normals_make_consistent(inside=False)
#+END_SRC
** Make faces between two or more edge loops
#+BEGIN_SRC python
  .bridge_edge_loops(type='SINGLE', use_merge=False, merge_factor=0.5, twist_offset=0, number_cuts=0, interpolation='PATH', smoothness=1, profile_shape_factor=0, profile_shape='SMOOTH')
#+END_SRC
** Merge selected vertices
#+BEGIN_SRC python
  .merge(type='CENTER', uvs=False)
#+END_SRC
** Randomly select vertices
#+BEGIN_SRC python
  .select_random(percent=50, extend=False)
#+END_SRC
** Rearrange some faces to try to get less degenerated geometry
#+BEGIN_SRC python
  .beautify_fill()
#+END_SRC
** Remove UV Map
#+BEGIN_SRC python
  .uv_texture_remove()
#+END_SRC
** Remove duplicate vertices
#+BEGIN_SRC python
  .remove_doubles(threshold=0.0001, use_unselected=False)
#+END_SRC
** Remove navmesh data from this mesh
#+BEGIN_SRC python
  .navmesh_clear()
#+END_SRC
** Remove vertex color layer
#+BEGIN_SRC python
  .vertex_color_remove()
#+END_SRC
** Reveal all hidden vertices, edges and faces
#+BEGIN_SRC python
  .reveal()
#+END_SRC
** Rip polygons and move the result
#+BEGIN_SRC python
  .rip_move(MESH_OT_rip={"mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "release_confirm":False, "use_fill":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Rip-fill polygons and move the result
#+BEGIN_SRC python
  .rip_move_fill(MESH_OT_rip={"mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "release_confirm":False, "use_fill":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Rotate UV coordinates inside faces
#+BEGIN_SRC python
  .uvs_rotate(use_ccw=False)
#+END_SRC
** Rotate selected edge or adjoining faces
#+BEGIN_SRC python
  .edge_rotate(use_ccw=False)
#+END_SRC
** Rotate vertex colors inside faces
#+BEGIN_SRC python
  .colors_rotate(use_ccw=False)
#+END_SRC
** Select a loop of connected edges
#+BEGIN_SRC python
  .loop_select(extend=False, deselect=False, toggle=False, ring=False)
#+END_SRC
** Select a loop of connected edges by connection type
#+BEGIN_SRC python
  .loop_multi_select(ring=False)
#+END_SRC
** Select all data in the mesh on a single axis
#+BEGIN_SRC python
  .select_axis(mode='POSITIVE', axis='X_AXIS')
#+END_SRC
** Select all non-manifold vertices or edges
#+BEGIN_SRC python
  .select_non_manifold(extend=True)
#+END_SRC
** Select all sharp-enough edges
#+BEGIN_SRC python
  .edges_select_sharp(sharpness=0.523599)
#+END_SRC
** Select all vertices linked to the active mesh
#+BEGIN_SRC python
  .select_linked(limit=False)
#+END_SRC
** Select an edge ring
#+BEGIN_SRC python
  .edgering_select(extend=False, deselect=False, toggle=False, ring=True)
#+END_SRC
** Select boundary edges around the selected faces
#+BEGIN_SRC python
  .region_to_loop()
#+END_SRC
** Select faces where all edges have more than 2 face users
#+BEGIN_SRC python
  .select_interior_faces()
#+END_SRC
** Select linked faces by angle
#+BEGIN_SRC python
  .faces_select_linked_flat(sharpness=0.0174533)
#+END_SRC
** Select loose geometry based on the selection mode
#+BEGIN_SRC python
  .select_loose(extend=False)
#+END_SRC
** Select mesh items at mirrored locations
#+BEGIN_SRC python
  .select_mirror(extend=False)
#+END_SRC
** Select more vertices, edges or faces connected to initial selection
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select next edge loop adjacent to a selected loop
#+BEGIN_SRC python
  .select_next_loop()
#+END_SRC
** Select region of faces inside of a selected loop of edges
#+BEGIN_SRC python
  .loop_to_region(select_bigger=False)
#+END_SRC
** Select shortest path between two selections
#+BEGIN_SRC python
  .shortest_path_pick(extend=False)
#+END_SRC
** Select similar vertices, edges or faces by property types
#+BEGIN_SRC python
  .select_similar(type='NORMAL', compare='EQUAL', threshold=0)
#+END_SRC
** Select vertices or faces by the number of polygon sides
#+BEGIN_SRC python
  .select_face_by_sides(number=4, type='EQUAL', extend=True)
#+END_SRC
** Select vertices without a group
#+BEGIN_SRC python
  .select_ungrouped(extend=False)
#+END_SRC
** Selected vertex path between two vertices
#+BEGIN_SRC python
  .shortest_path_select(use_length=True)
#+END_SRC
** Separate selected geometry into a new mesh
#+BEGIN_SRC python
  .separate(type='SELECTED')
#+END_SRC
** Snap vertex pairs to their mirrored locations
#+BEGIN_SRC python
  .symmetry_snap(direction='NEGATIVE_X', threshold=0.05, factor=0.5, use_center=True)
#+END_SRC
** Split a face into a fan
#+BEGIN_SRC python
  .poke(offset=0, use_relative_offset=False, center_mode='MEAN_WEIGHTED')
#+END_SRC
** Split non-planar faces that exceed the angle threshold
#+BEGIN_SRC python
  .vert_connect_nonplanar(angle_limit=0.0872665)
#+END_SRC
** Split off selected geometry from connected unselected geometry
#+BEGIN_SRC python
  .split()
#+END_SRC
** Split selected edges so that each neighbor face gets its own copy
#+BEGIN_SRC python
  .edge_split()
#+END_SRC
** Subdivide selected edges
#+BEGIN_SRC python
  .subdivide(number_cuts=1, smoothness=0, quadtri=False, quadcorner='STRAIGHT_CUT', fractal=0, fractal_along_normal=0, seed=0)
#+END_SRC
** The order of selected vertices/edges/faces is modified, based on a given method
#+BEGIN_SRC python
  .sort_elements(type='VIEW_ZAXIS', elements=set(), reverse=False, seed=0)
#+END_SRC
** Triangulate selected faces
#+BEGIN_SRC python
  .quads_convert_to_tris(quad_method='BEAUTY', ngon_method='BEAUTY')
#+END_SRC
** UnSubdivide selected edges & faces
#+BEGIN_SRC python
  .unsubdivide(iterations=2)
#+END_SRC
** Use other objects outlines & boundaries to project knife cuts
#+BEGIN_SRC python
  .knife_project()
#+END_SRC
** Use vertex coordinate as texture coordinate
#+BEGIN_SRC python
  .noise(factor=0.1)
#+END_SRC
** subdivide_edgering
#+BEGIN_SRC python
  .subdivide_edgering(number_cuts=10, interpolation='PATH', smoothness=1, profile_shape_factor=0, profile_shape='SMOOTH')
#+END_SRC
* bpy.ops.nla
** Add NLA-Tracks above/after the selected tracks
#+BEGIN_SRC python
  .tracks_add(above_selected=False)
#+END_SRC
** Add a F-Modifier of the specified type to the selected NLA-Strips
#+BEGIN_SRC python
  .fmodifier_add(type='NULL', only_active=False)
#+END_SRC
** Add a strip for controlling when speaker plays its sound clip
#+BEGIN_SRC python
  .soundclip_add()
#+END_SRC
** Add a transition strip between two adjacent selected strips
#+BEGIN_SRC python
  .transition_add()
#+END_SRC
** Add an Action-Clip strip (i.e. an NLA Strip referencing an Action) to the active track
#+BEGIN_SRC python
  .actionclip_add(action='<UNKNOWN ENUM>')
#+END_SRC
** Add copied F-Modifiers to the selected NLA-Strips
#+BEGIN_SRC python
  .fmodifier_paste()
#+END_SRC
** Add new meta-strips incorporating the selected strips
#+BEGIN_SRC python
  .meta_add()
#+END_SRC
** Apply scaling of selected strips to their referenced Actions
#+BEGIN_SRC python
  .apply_scale()
#+END_SRC
** Bake object/pose loc/scale/rotation animation to a new action
#+BEGIN_SRC python
  .bake(frame_start=1, frame_end=250, step=1, only_selected=True, visual_keying=False, clear_constraints=False, clear_parents=False, bake_types={, 'POSE'})
#+END_SRC
** Copy the F-Modifier(s) of the active NLA-Strip
#+BEGIN_SRC python
  .fmodifier_copy()
#+END_SRC
** Delete selected NLA-Tracks and the strips they contain
#+BEGIN_SRC python
  .tracks_delete()
#+END_SRC
** Delete selected strips
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Duplicate selected NLA-Strips, adding the new strips in new tracks above the originals
#+BEGIN_SRC python
  .duplicate(mode='TRANSLATION')
#+END_SRC
** Enter tweaking mode for the action referenced by the active strip
#+BEGIN_SRC python
  .tweakmode_enter()
#+END_SRC
** Exit tweaking mode for the action referenced by the active strip
#+BEGIN_SRC python
  .tweakmode_exit()
#+END_SRC
** Handle clicks to select NLA Strips
#+BEGIN_SRC python
  .click_select(extend=False)
#+END_SRC
** Handle clicks to select NLA channels
#+BEGIN_SRC python
  .channels_click(extend=False)
#+END_SRC
** Make selected objects appear in NLA Editor by adding Animation Data
#+BEGIN_SRC python
  .selected_objects_add()
#+END_SRC
** Move selected strips down a track if there's room
#+BEGIN_SRC python
  .move_down()
#+END_SRC
** Move selected strips up a track if there's room
#+BEGIN_SRC python
  .move_up()
#+END_SRC
** Move start of strips to specified time
#+BEGIN_SRC python
  .snap(type='CFRA')
#+END_SRC
** Mute or un-mute selected strips
#+BEGIN_SRC python
  .mute_toggle()
#+END_SRC
** Reset scaling of selected strips
#+BEGIN_SRC python
  .clear_scale()
#+END_SRC
** Reset viewable area to show full strips range
#+BEGIN_SRC python
  .view_all()
#+END_SRC
** Reset viewable area to show selected strips range
#+BEGIN_SRC python
  .view_selected()
#+END_SRC
** Select or deselect all NLA-Strips
#+BEGIN_SRC python
  .select_all_toggle(invert=False)
#+END_SRC
** Select strips to the left or the right of the current frame
#+BEGIN_SRC python
  .select_leftright(mode='CHECK', extend=False)
#+END_SRC
** Separate out the strips held by the selected meta-strips
#+BEGIN_SRC python
  .meta_remove()
#+END_SRC
** Split selected strips at their midpoints
#+BEGIN_SRC python
  .split()
#+END_SRC
** Swap order of selected strips within tracks
#+BEGIN_SRC python
  .swap()
#+END_SRC
** Synchronize the length of the referenced Action with the length used in the strip
#+BEGIN_SRC python
  .action_sync_length(active=True)
#+END_SRC
** Toggle display properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Use box selection to grab NLA-Strips
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, axis_range=False)
#+END_SRC
* bpy.ops.node
** (De)select all nodes
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Activate and view same node type, step by step
#+BEGIN_SRC python
  .select_same_type_step(prev=False)
#+END_SRC
** Add a Node Color Preset
#+BEGIN_SRC python
  .node_color_preset_add(remove_active=False, name="")
#+END_SRC
** Add a file node to the current node editor
#+BEGIN_SRC python
  .add_file(filepath="", filter_blender=False, filter_backup=False, filter_image=True, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY', name="Image")
#+END_SRC
** Add a mask node to the current node editor
#+BEGIN_SRC python
  .add_mask(name="Mask")
#+END_SRC
** Add a new input to a file output node
#+BEGIN_SRC python
  .output_file_add_socket(file_path="Image")
#+END_SRC
** Add a node to the active tree
#+BEGIN_SRC python
  .add_node(use_transform=False, type="", settings=[])
#+END_SRC
** Add a node to the active tree
#+BEGIN_SRC python
  .add_search(use_transform=False, type="", settings=[], node_item='<UNKNOWN ENUM>')
#+END_SRC
** Add a node to the active tree and link to an existing socket
#+BEGIN_SRC python
  .add_and_link_node(use_transform=False, type="", settings=[], link_socket_index=0)
#+END_SRC
** Add a reroute node
#+BEGIN_SRC python
  .add_reroute(path=[], cursor=6)
#+END_SRC
** Add an input or output socket to the current node tree
#+BEGIN_SRC python
  .tree_socket_add(in_out='IN')
#+END_SRC
** Attach active node to a frame
#+BEGIN_SRC python
  .attach()
#+END_SRC
** Attach selected nodes
#+BEGIN_SRC python
  .parent_set()
#+END_SRC
** Attach selected nodes to a new common frame
#+BEGIN_SRC python
  .join()
#+END_SRC
** Copies selected nodes to the clipboard
#+BEGIN_SRC python
  .clipboard_copy()
#+END_SRC
** Copy color to all selected nodes
#+BEGIN_SRC python
  .node_copy_color()
#+END_SRC
** Create a new node tree
#+BEGIN_SRC python
  .new_node_tree(type='ShaderNodeTree', name="NodeTree")
#+END_SRC
** Delete nodes; will reconnect nodes as if deletion was muted
#+BEGIN_SRC python
  .delete_reconnect()
#+END_SRC
** Delete selected nodes
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Detach nodes, move and attach to frame
#+BEGIN_SRC python
  .detach_translate_attach(NODE_OT_detach={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False}, NODE_OT_attach={})
#+END_SRC
** Detach selected nodes
#+BEGIN_SRC python
  .parent_clear()
#+END_SRC
** Detach selected nodes from parents
#+BEGIN_SRC python
  .detach()
#+END_SRC
** Duplicate selected nodes
#+BEGIN_SRC python
  .duplicate(keep_inputs=False)
#+END_SRC
** Duplicate selected nodes and move them
#+BEGIN_SRC python
  .duplicate_move(NODE_OT_duplicate={"keep_inputs":False}, NODE_OT_translate_attach={"TRANSFORM_OT_translate":{"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False}, "NODE_OT_attach":{}})
#+END_SRC
** Duplicate selected nodes keeping input links and move them
#+BEGIN_SRC python
  .duplicate_move_keep_inputs(NODE_OT_duplicate={"keep_inputs":False}, NODE_OT_translate_attach={"TRANSFORM_OT_translate":{"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False}, "NODE_OT_attach":{}})
#+END_SRC
** Edit node group
#+BEGIN_SRC python
  .group_edit(exit=False)
#+END_SRC
** Fit the background image to the view
#+BEGIN_SRC python
  .backimage_fit()
#+END_SRC
** Go to parent node tree
#+BEGIN_SRC python
  .tree_path_parent()
#+END_SRC
** Insert selected nodes into a node group
#+BEGIN_SRC python
  .group_insert()
#+END_SRC
** Link to viewer node
#+BEGIN_SRC python
  .link_viewer()
#+END_SRC
** Make group from selected nodes
#+BEGIN_SRC python
  .group_make()
#+END_SRC
** Makes a link between selected output in input sockets
#+BEGIN_SRC python
  .link_make(replace=False)
#+END_SRC
** Move Node backdrop
#+BEGIN_SRC python
  .backimage_move()
#+END_SRC
** Move a node to detach links
#+BEGIN_SRC python
  .move_detach_links(NODE_OT_links_detach={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Move a node to detach links
#+BEGIN_SRC python
  .move_detach_links_release(NODE_OT_links_detach={}, NODE_OT_translate_attach={"TRANSFORM_OT_translate":{"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False}, "NODE_OT_attach":{}})
#+END_SRC
** Move a socket up or down in the current node tree's sockets stack
#+BEGIN_SRC python
  .tree_socket_move(direction='UP')
#+END_SRC
** Move nodes and attach to frame
#+BEGIN_SRC python
  .translate_attach(TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False}, NODE_OT_attach={})
#+END_SRC
** Move the active input of a file output node up or down the list
#+BEGIN_SRC python
  .output_file_move_active_socket(direction='DOWN')
#+END_SRC
** Pastes nodes from the clipboard to the active node tree
#+BEGIN_SRC python
  .clipboard_paste()
#+END_SRC
** Read all render layers of all used scenes
#+BEGIN_SRC python
  .read_renderlayers()
#+END_SRC
** Read all render layers of current scene, in full sample
#+BEGIN_SRC python
  .read_fullsamplelayers()
#+END_SRC
** Remove active input from a file output node
#+BEGIN_SRC python
  .output_file_remove_active_socket()
#+END_SRC
** Remove all links to selected nodes, and try to connect neighbor nodes together
#+BEGIN_SRC python
  .links_detach()
#+END_SRC
** Remove an input or output socket to the current node tree
#+BEGIN_SRC python
  .tree_socket_remove()
#+END_SRC
** Render current scene, when input node's layer has been changed
#+BEGIN_SRC python
  .render_changed()
#+END_SRC
** Resize a node
#+BEGIN_SRC python
  .resize()
#+END_SRC
** Resize view so you can see all nodes
#+BEGIN_SRC python
  .view_all()
#+END_SRC
** Resize view so you can see selected nodes
#+BEGIN_SRC python
  .view_selected()
#+END_SRC
** Search for named node and allow to select and activate it
#+BEGIN_SRC python
  .find_node(prev=False)
#+END_SRC
** Select all the nodes of the same type
#+BEGIN_SRC python
  .select_same_type()
#+END_SRC
** Select node and link it to a viewer node
#+BEGIN_SRC python
  .select_link_viewer(NODE_OT_select={"mouse_x":0, "mouse_y":0, "extend":False}, NODE_OT_link_viewer={})
#+END_SRC
** Select nodes linked from the selected ones
#+BEGIN_SRC python
  .select_linked_from()
#+END_SRC
** Select nodes linked to the selected ones
#+BEGIN_SRC python
  .select_linked_to()
#+END_SRC
** Select nodes using lasso selection
#+BEGIN_SRC python
  .select_lasso(path=[], deselect=False, extend=True)
#+END_SRC
** Select the node under the cursor
#+BEGIN_SRC python
  .select(mouse_x=0, mouse_y=0, extend=False)
#+END_SRC
** Separate selected nodes from the node group
#+BEGIN_SRC python
  .group_separate(type='COPY')
#+END_SRC
** Set the boundaries for viewer operations
#+BEGIN_SRC python
  .viewer_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Sort the nodes and show the cyclic dependencies between the nodes
#+BEGIN_SRC python
  .show_cyclic_dependencies()
#+END_SRC
** Toggle collapsed nodes and hide unused sockets
#+BEGIN_SRC python
  .collapse_hide_unused_toggle()
#+END_SRC
** Toggle hiding of selected nodes
#+BEGIN_SRC python
  .hide_toggle()
#+END_SRC
** Toggle muting of the nodes
#+BEGIN_SRC python
  .mute_toggle()
#+END_SRC
** Toggle option buttons display for selected nodes
#+BEGIN_SRC python
  .options_toggle()
#+END_SRC
** Toggle preview display for selected nodes
#+BEGIN_SRC python
  .preview_toggle()
#+END_SRC
** Toggle unused node socket display
#+BEGIN_SRC python
  .hide_socket_toggle()
#+END_SRC
** Toggles the properties panel display
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Toggles tool shelf display
#+BEGIN_SRC python
  .toolbar()
#+END_SRC
** Ungroup selected nodes
#+BEGIN_SRC python
  .group_ungroup()
#+END_SRC
** Update shader script node with new sockets and options from the script
#+BEGIN_SRC python
  .shader_script_update()
#+END_SRC
** Use box selection to select nodes
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, tweak=False)
#+END_SRC
** Use mouse to sample background image
#+BEGIN_SRC python
  .backimage_sample()
#+END_SRC
** Use the mouse to create a link between two nodes
#+BEGIN_SRC python
  .link(detach=False)
#+END_SRC
** Use the mouse to cut (remove) some links
#+BEGIN_SRC python
  .links_cut(path=[], cursor=9)
#+END_SRC
** Zoom in/out the background image
#+BEGIN_SRC python
  .backimage_zoom(factor=1.2)
#+END_SRC
* bpy.ops.object
** Add a camera object to the scene
#+BEGIN_SRC python
  .camera_add(view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add a constraint to the active object
#+BEGIN_SRC python
  .constraint_add(type='<UNKNOWN ENUM>')
#+END_SRC
** Add a constraint to the active object, with target (where applicable) set to the selected Objects/Bones
#+BEGIN_SRC python
  .constraint_add_with_targets(type='<UNKNOWN ENUM>')
#+END_SRC
** Add a dupligroup instance
#+BEGIN_SRC python
  .group_instance_add(name="Group", group='<UNKNOWN ENUM>', view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add a lamp object to the scene
#+BEGIN_SRC python
  .lamp_add(type='POINT', view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add a modifier to the active object
#+BEGIN_SRC python
  .modifier_add(type='SUBSURF')
#+END_SRC
** Add a new level of subdivision
#+BEGIN_SRC python
  .multires_subdivide(modifier="")
#+END_SRC
** Add a new material slot
#+BEGIN_SRC python
  .material_slot_add()
#+END_SRC
** Add a new vertex group to the active object
#+BEGIN_SRC python
  .vertex_group_add()
#+END_SRC
** Add a particle system
#+BEGIN_SRC python
  .particle_system_add()
#+END_SRC
** Add a speaker object to the scene
#+BEGIN_SRC python
  .speaker_add(view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add a text object to the scene
#+BEGIN_SRC python
  .text_add(view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add an armature object to the scene
#+BEGIN_SRC python
  .armature_add(view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add an empty image type to scene with data
#+BEGIN_SRC python
  .drop_named_image(filepath="", name="", view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add an empty object to the scene
#+BEGIN_SRC python
  .empty_add(type='PLAIN_AXES', view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add an empty object with a physics effector to the scene
#+BEGIN_SRC python
  .effector_add(type='FORCE', view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add an metaball object to the scene
#+BEGIN_SRC python
  .metaball_add(type='BALL', radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add an object to a new group
#+BEGIN_SRC python
  .group_add()
#+END_SRC
** Add an object to an existing group
#+BEGIN_SRC python
  .group_link(group='<UNKNOWN ENUM>')
#+END_SRC
** Add an object to the scene
#+BEGIN_SRC python
  .add(type='EMPTY', view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Add empty object to become local replacement data of a library-linked object
#+BEGIN_SRC python
  .proxy_make(object='DEFAULT')
#+END_SRC
** Add named object
#+BEGIN_SRC python
  .add_named(linked=False, name="Cube")
#+END_SRC
** Add shape key to the object
#+BEGIN_SRC python
  .shape_key_add(from_mix=True)
#+END_SRC
** Add some offset and multiply with some gain the weights of the active vertex group
#+BEGIN_SRC python
  .vertex_group_levels(group_select_mode='ACTIVE', offset=0, gain=1)
#+END_SRC
** Align Objects
#+BEGIN_SRC python
  .align(bb_quality=True, align_mode='OPT_2', relative_to='OPT_4', align_axis=set())
#+END_SRC
** Apply modifier and remove from the stack
#+BEGIN_SRC python
  .modifier_apply(apply_as='DATA', modifier="")
#+END_SRC
** Apply the object's transformation to its data
#+BEGIN_SRC python
  .transform_apply(location=False, rotation=False, scale=False)
#+END_SRC
** Apply the object's visual transformation to its data
#+BEGIN_SRC python
  .visual_transform_apply()
#+END_SRC
** Assign active material slot to selection
#+BEGIN_SRC python
  .material_slot_assign()
#+END_SRC
** Assign the selected vertices to a hook
#+BEGIN_SRC python
  .hook_assign(modifier='<UNKNOWN ENUM>')
#+END_SRC
** Assign the selected vertices to a new vertex group
#+BEGIN_SRC python
  .vertex_group_assign_new()
#+END_SRC
** Assign the selected vertices to the active vertex group
#+BEGIN_SRC python
  .vertex_group_assign()
#+END_SRC
** Bake an image sequence of ocean data
#+BEGIN_SRC python
  .ocean_bake(modifier="", free=False)
#+END_SRC
** Bake image textures of selected objects
#+BEGIN_SRC python
  .bake_image()
#+END_SRC
** Bind mesh to cage in mesh deform modifier
#+BEGIN_SRC python
  .meshdeform_bind(modifier="")
#+END_SRC
** Blend selected vertex weights with unselected for the active group
#+BEGIN_SRC python
  .vertex_group_blend(group_select_mode='ACTIVE', factor=1)
#+END_SRC
** Calculate motion paths for the selected objects
#+BEGIN_SRC python
  .paths_calculate(start_frame=1, end_frame=250)
#+END_SRC
** Change selection of all visible objects in scene
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Change the lock state of all vertex groups of active object
#+BEGIN_SRC python
  .vertex_group_lock(action='TOGGLE')
#+END_SRC
** Clear all the constraints for the active Object only
#+BEGIN_SRC python
  .constraints_clear()
#+END_SRC
** Clear path caches for selected objects
#+BEGIN_SRC python
  .paths_clear()
#+END_SRC
** Clear the object's location
#+BEGIN_SRC python
  .location_clear()
#+END_SRC
** Clear the object's origin
#+BEGIN_SRC python
  .origin_clear()
#+END_SRC
** Clear the object's parenting
#+BEGIN_SRC python
  .parent_clear(type='CLEAR')
#+END_SRC
** Clear the object's rotation
#+BEGIN_SRC python
  .rotation_clear()
#+END_SRC
** Clear the object's scale
#+BEGIN_SRC python
  .scale_clear()
#+END_SRC
** Clear the object's slow parent
#+BEGIN_SRC python
  .slow_parent_clear()
#+END_SRC
** Clear tracking constraint or flag from object
#+BEGIN_SRC python
  .track_clear(type='CLEAR')
#+END_SRC
** Clear weights for all shape keys
#+BEGIN_SRC python
  .shape_key_clear()
#+END_SRC
** Convert object animation for normal transforms to delta transforms
#+BEGIN_SRC python
  .anim_transforms_to_deltas()
#+END_SRC
** Convert particles to a mesh object
#+BEGIN_SRC python
  .modifier_convert(modifier="")
#+END_SRC
** Convert selected objects to another type
#+BEGIN_SRC python
  .convert(target='MESH', keep_original=False)
#+END_SRC
** Copies materials to other selected objects
#+BEGIN_SRC python
  .material_slot_copy()
#+END_SRC
** Copy another selected objects active shape to this one by applying the relative offsets
#+BEGIN_SRC python
  .shape_key_transfer(mode='OFFSET', use_clamp=False)
#+END_SRC
** Copy constraints to other selected objects
#+BEGIN_SRC python
  .constraints_copy()
#+END_SRC
** Copy game physics properties to other selected objects
#+BEGIN_SRC python
  .game_physics_copy()
#+END_SRC
** Copy logic bricks to other selected objects
#+BEGIN_SRC python
  .logic_bricks_copy()
#+END_SRC
** Copy this group's weight to other selected verts (disabled if vertex group is locked)
#+BEGIN_SRC python
  .vertex_weight_paste(weight_group=-1)
#+END_SRC
** Copy vertex coordinates from other object
#+BEGIN_SRC python
  .multires_reshape(modifier="")
#+END_SRC
** Copy vertex groups to all users of the same geometry data
#+BEGIN_SRC python
  .vertex_group_copy_to_linked()
#+END_SRC
** Copy vertex groups to other selected objects with matching indices
#+BEGIN_SRC python
  .vertex_group_copy_to_selected()
#+END_SRC
** Copy weights from active to selected
#+BEGIN_SRC python
  .vertex_weight_copy()
#+END_SRC
** Copy/merge/replace a game property from active object to all selected objects
#+BEGIN_SRC python
  .game_property_copy(operation='COPY', property='<UNKNOWN ENUM>')
#+END_SRC
** Create a new property available to the game engine
#+BEGIN_SRC python
  .game_property_new(type='FLOAT', name="")
#+END_SRC
** Create an armature that parallels the skin layout
#+BEGIN_SRC python
  .skin_armature_create(modifier="")
#+END_SRC
** Delete selected objects
#+BEGIN_SRC python
  .delete(use_global=False)
#+END_SRC
** Delete the active or all vertex groups from the active object
#+BEGIN_SRC python
  .vertex_group_remove(all=False)
#+END_SRC
** Delete this weight from the vertex (disabled if vertex group is locked)
#+BEGIN_SRC python
  .vertex_weight_delete(weight_group=-1)
#+END_SRC
** Deletes the higher resolution mesh, potential loss of detail
#+BEGIN_SRC python
  .multires_higher_levels_delete(modifier="")
#+END_SRC
** Deselect all selected vertices assigned to the active vertex group
#+BEGIN_SRC python
  .vertex_group_deselect()
#+END_SRC
** Deselect by active material slot
#+BEGIN_SRC python
  .material_slot_deselect()
#+END_SRC
** Duplicate modifier at the same position in the stack
#+BEGIN_SRC python
  .modifier_copy(modifier="")
#+END_SRC
** Duplicate selected objects
#+BEGIN_SRC python
  .duplicate(linked=False, mode='TRANSLATION')
#+END_SRC
** Duplicate selected objects and move them
#+BEGIN_SRC python
  .duplicate_move(OBJECT_OT_duplicate={"linked":False, "mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Duplicate selected objects and move them
#+BEGIN_SRC python
  .duplicate_move_linked(OBJECT_OT_duplicate={"linked":False, "mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Enable or disable posing/selecting bones
#+BEGIN_SRC python
  .posemode_toggle()
#+END_SRC
** Hide the object by setting the hide flag
#+BEGIN_SRC python
  .hide_view_set(unselected=False)
#+END_SRC
** Hide the render object by setting the hide render flag
#+BEGIN_SRC python
  .hide_render_set(unselected=False)
#+END_SRC
** Hide unselected render objects of same type as active by setting the hide render flag
#+BEGIN_SRC python
  .isolate_type_render()
#+END_SRC
** Hook selected vertices to a newly created object
#+BEGIN_SRC python
  .hook_add_newob()
#+END_SRC
** Hook selected vertices to the first selected object
#+BEGIN_SRC python
  .hook_add_selob(use_bone=False)
#+END_SRC
** Invert active vertex group's weights
#+BEGIN_SRC python
  .vertex_group_invert(group_select_mode='ACTIVE', auto_assign=True, auto_remove=True)
#+END_SRC
** Join selected objects into active object
#+BEGIN_SRC python
  .join()
#+END_SRC
** Limit deform weights associated with a vertex to a specified number by removing lowest weights
#+BEGIN_SRC python
  .vertex_group_limit_total(group_select_mode='ALL', limit=4)
#+END_SRC
** Link selection to another scene
#+BEGIN_SRC python
  .make_links_scene(scene='Scene')
#+END_SRC
** Make a copy of the active vertex group
#+BEGIN_SRC python
  .vertex_group_copy()
#+END_SRC
** Make dupli objects attached to this object real
#+BEGIN_SRC python
  .duplicates_make_real(use_base_parent=False, use_hierarchy=False)
#+END_SRC
** Make library linked datablocks local to this file
#+BEGIN_SRC python
  .make_local(type='SELECT_OBJECT')
#+END_SRC
** Make linked data local to each object
#+BEGIN_SRC python
  .make_single_user(type='SELECTED_OBJECTS', object=False, obdata=False, material=False, texture=False, animation=False)
#+END_SRC
** Make linked objects into dupli-faces
#+BEGIN_SRC python
  .make_dupli_face()
#+END_SRC
** Make links from the active object to other selected objects
#+BEGIN_SRC python
  .make_links_data(type='OBDATA')
#+END_SRC
** Make skin radii of selected vertices equal on each axis
#+BEGIN_SRC python
  .skin_radii_equalize()
#+END_SRC
** Make the object track another object, either by constraint or old way or locked track
#+BEGIN_SRC python
  .track_set(type='DAMPTRACK')
#+END_SRC
** Mark selected vertices as roots
#+BEGIN_SRC python
  .skin_root_mark()
#+END_SRC
** Mark/clear selected vertices as loose
#+BEGIN_SRC python
  .skin_loose_mark_clear(action='MARK')
#+END_SRC
** Merge selected objects to shapes of active object
#+BEGIN_SRC python
  .join_shapes()
#+END_SRC
** Mirror all vertex groups, flip weights and/or names, editing only selected vertices, flipping when both sides are selected otherwise copy from unselected
#+BEGIN_SRC python
  .vertex_group_mirror(mirror_weights=True, flip_group_names=True, all_groups=False, use_topology=False)
#+END_SRC
** Mirror the current shape key along the local X axis
#+BEGIN_SRC python
  .shape_key_mirror(use_topology=False)
#+END_SRC
** Modify the base mesh to conform to the displaced mesh
#+BEGIN_SRC python
  .multires_base_apply(modifier="")
#+END_SRC
** Modify the position of selected vertices by changing only their respective groups' weights (this tool may be slow for many vertices)
#+BEGIN_SRC python
  .vertex_group_fix(dist=0, strength=1, accuracy=1)
#+END_SRC
** Move modifier down in the stack
#+BEGIN_SRC python
  .modifier_move_down(modifier="")
#+END_SRC
** Move modifier up in the stack
#+BEGIN_SRC python
  .modifier_move_up(modifier="")
#+END_SRC
** Move the active shape key up/down in the list
#+BEGIN_SRC python
  .shape_key_move(type='UP')
#+END_SRC
** Move the active vertex group up/down in the list
#+BEGIN_SRC python
  .vertex_group_move(direction='UP')
#+END_SRC
** Move the object to different layers
#+BEGIN_SRC python
  .move_to_layer(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Normalize active vertex's weights
#+BEGIN_SRC python
  .vertex_weight_normalize_active_vertex()
#+END_SRC
** Normalize all weights of all vertex groups, so that for each vertex, the sum of all weights is 1.0
#+BEGIN_SRC python
  .vertex_group_normalize_all(group_select_mode='ALL', lock_active=True)
#+END_SRC
** Normalize weights of the active vertex group, so that the highest ones are now 1.0
#+BEGIN_SRC python
  .vertex_group_normalize()
#+END_SRC
** Pack displacements from an external file
#+BEGIN_SRC python
  .multires_external_pack()
#+END_SRC
** Parent selected objects to the selected vertices
#+BEGIN_SRC python
  .vertex_parent_set()
#+END_SRC
** Randomize objects loc/rot/scale
#+BEGIN_SRC python
  .randomize_transform(random_seed=0, use_delta=False, use_loc=True, loc=(0, 0, 0), use_rot=True, rot=(0, 0, 0), use_scale=True, scale_even=False, scale=(1, 1, 1))
#+END_SRC
** Recalculate and clear offset transformation
#+BEGIN_SRC python
  .hook_reset(modifier='<UNKNOWN ENUM>')
#+END_SRC
** Recalculate paths for selected objects
#+BEGIN_SRC python
  .paths_update()
#+END_SRC
** Refresh data in the Explode modifier
#+BEGIN_SRC python
  .explode_refresh(modifier="")
#+END_SRC
** Remove a hook from the active object
#+BEGIN_SRC python
  .hook_remove(modifier='<UNKNOWN ENUM>')
#+END_SRC
** Remove a modifier from the active object
#+BEGIN_SRC python
  .modifier_remove(modifier="")
#+END_SRC
** Remove all game properties from all selected objects
#+BEGIN_SRC python
  .game_property_clear()
#+END_SRC
** Remove game property
#+BEGIN_SRC python
  .game_property_remove(index=0)
#+END_SRC
** Remove shape key from the object
#+BEGIN_SRC python
  .shape_key_remove(all=False)
#+END_SRC
** Remove the active object from this group
#+BEGIN_SRC python
  .group_remove()
#+END_SRC
** Remove the selected material slot
#+BEGIN_SRC python
  .material_slot_remove()
#+END_SRC
** Remove the selected particle system
#+BEGIN_SRC python
  .particle_system_remove()
#+END_SRC
** Remove the selected vertices from active or all vertex group(s)
#+BEGIN_SRC python
  .vertex_group_remove_from(use_all_groups=False, use_all_verts=False)
#+END_SRC
** Remove vertex group assignments which are not required
#+BEGIN_SRC python
  .vertex_group_clean(group_select_mode='ACTIVE', limit=0, keep_single=False)
#+END_SRC
** Render and display faces smooth, using interpolated Vertex Normals
#+BEGIN_SRC python
  .shade_smooth()
#+END_SRC
** Render and display faces uniform, using Face Normals
#+BEGIN_SRC python
  .shade_flat()
#+END_SRC
** Resets the timing for absolute shape keys
#+BEGIN_SRC python
  .shape_key_retime()
#+END_SRC
** Reveal all render objects by setting the hide render flag
#+BEGIN_SRC python
  .hide_render_clear_all()
#+END_SRC
** Reveal the object by setting the hide flag
#+BEGIN_SRC python
  .hide_view_clear()
#+END_SRC
** Reveal the render object by setting the hide render flag
#+BEGIN_SRC python
  .hide_render_clear()
#+END_SRC
** Save displacements to an external file
#+BEGIN_SRC python
  .multires_external_save(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=True, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', modifier="")
#+END_SRC
** Select affected vertices on mesh
#+BEGIN_SRC python
  .hook_select(modifier='<UNKNOWN ENUM>')
#+END_SRC
** Select all the vertices assigned to the active vertex group
#+BEGIN_SRC python
  .vertex_group_select()
#+END_SRC
** Select all visible objects grouped by various properties
#+BEGIN_SRC python
  .select_grouped(extend=False, type='CHILDREN_RECURSIVE')
#+END_SRC
** Select all visible objects on a layer
#+BEGIN_SRC python
  .select_by_layer(match='EXACT', extend=False, layers=1)
#+END_SRC
** Select all visible objects that are linked
#+BEGIN_SRC python
  .select_linked(extend=False, type='OBDATA')
#+END_SRC
** Select all visible objects that are of a type
#+BEGIN_SRC python
  .select_by_type(extend=False, type='MESH')
#+END_SRC
** Select by active material slot
#+BEGIN_SRC python
  .material_slot_select()
#+END_SRC
** Select object in the same group
#+BEGIN_SRC python
  .select_same_group(group="")
#+END_SRC
** Select object relative to the active object's position in the hierarchy
#+BEGIN_SRC python
  .select_hierarchy(direction='PARENT', extend=False)
#+END_SRC
** Select objects matching a naming pattern
#+BEGIN_SRC python
  .select_pattern(pattern="*", case_sensitive=False, extend=True)
#+END_SRC
** Select the Mirror objects of the selected object eg. L.sword -> R.sword
#+BEGIN_SRC python
  .select_mirror(extend=False)
#+END_SRC
** Select the active camera
#+BEGIN_SRC python
  .select_camera(extend=False)
#+END_SRC
** Set as active vertex group
#+BEGIN_SRC python
  .vertex_weight_set_active(weight_group=-1)
#+END_SRC
** Set hook center to cursor position
#+BEGIN_SRC python
  .hook_recenter(modifier='<UNKNOWN ENUM>')
#+END_SRC
** Set offset used for DupliGroup based on cursor position
#+BEGIN_SRC python
  .dupli_offset_from_cursor(group=0)
#+END_SRC
** Set select on random visible objects
#+BEGIN_SRC python
  .select_random(percent=50, extend=False)
#+END_SRC
** Set the active vertex group
#+BEGIN_SRC python
  .vertex_group_set_active(group='<UNKNOWN ENUM>')
#+END_SRC
** Set the object's origin, by either moving the data, or set to center of data, or use 3D cursor
#+BEGIN_SRC python
  .origin_set(type='GEOMETRY_ORIGIN', center='MEDIAN')
#+END_SRC
** Set the object's parenting
#+BEGIN_SRC python
  .parent_set(type='OBJECT', xmirror=False, keep_transform=False)
#+END_SRC
** Set the object's parenting without setting the inverse parent correction
#+BEGIN_SRC python
  .parent_no_inverse_set()
#+END_SRC
** Set the object's slow parent
#+BEGIN_SRC python
  .slow_parent_set()
#+END_SRC
** Sets a Subdivision Surface Level (1-5)
#+BEGIN_SRC python
  .subdivision_set(level=1, relative=False)
#+END_SRC
** Sets the object interaction mode
#+BEGIN_SRC python
  .mode_set(mode='OBJECT', toggle=False)
#+END_SRC
** Sort vertex groups alphabetically
#+BEGIN_SRC python
  .vertex_group_sort()
#+END_SRC
** Toggle object's editmode
#+BEGIN_SRC python
  .editmode_toggle()
#+END_SRC
** Toggle object's force field
#+BEGIN_SRC python
  .forcefield_toggle()
#+END_SRC
** Transfer UV Layouts from active to selected objects (needs matching geometry)
#+BEGIN_SRC python
  .join_uvs()
#+END_SRC
** Transfer weight paint to active from selected mesh
#+BEGIN_SRC python
  .vertex_group_transfer_weight(group_select_mode='WT_REPLACE_ALL_VERTEX_GROUPS', method='WT_BY_NEAREST_FACE', replace_mode='WT_REPLACE_ALL_WEIGHTS')
#+END_SRC
** drop_named_material
#+BEGIN_SRC python
  .drop_named_material(name="Material")
#+END_SRC
** quick_explode
#+BEGIN_SRC python
  .quick_explode(style='EXPLODE', amount=100, frame_duration=50, frame_start=1, frame_end=10, velocity=1, fade=True)
#+END_SRC
** quick_fluid
#+BEGIN_SRC python
  .quick_fluid(style='BASIC', initial_velocity=(0, 0, 0), show_flows=False, start_baking=False)
#+END_SRC
** quick_fur
#+BEGIN_SRC python
  .quick_fur(density='MEDIUM', view_percentage=10, length=0.1)
#+END_SRC
** quick_smoke
#+BEGIN_SRC python
  .quick_smoke(style='STREAM', show_flows=False)
#+END_SRC
* bpy.ops.outliner
** Add drivers to selected items
#+BEGIN_SRC python
  .drivers_add_selected()
#+END_SRC
** Add selected items (blue-gray rows) to active Keying Set
#+BEGIN_SRC python
  .keyingset_add_selected()
#+END_SRC
** Adjust the view so that the active Object is shown centered
#+BEGIN_SRC python
  .show_active()
#+END_SRC
** Change the active action used
#+BEGIN_SRC python
  .action_set(action='<UNKNOWN ENUM>')
#+END_SRC
** Context menu for item operations
#+BEGIN_SRC python
  .operation()
#+END_SRC
** Delete drivers assigned to selected items
#+BEGIN_SRC python
  .drivers_delete_selected()
#+END_SRC
** Drag material to object in Outliner
#+BEGIN_SRC python
  .material_drop(object="Object", material="Material")
#+END_SRC
** Drag object to scene in Outliner
#+BEGIN_SRC python
  .scene_drop(object="Object", scene="Scene")
#+END_SRC
** Drag to clear parent in Outliner
#+BEGIN_SRC python
  .parent_clear(dragged_obj="Object", type='CLEAR')
#+END_SRC
** Drag to parent in Outliner
#+BEGIN_SRC python
  .parent_drop(child="Object", parent="Object", type='OBJECT')
#+END_SRC
** Expand/Collapse all items
#+BEGIN_SRC python
  .expanded_toggle()
#+END_SRC
** Expand/collapse all entries by one level
#+BEGIN_SRC python
  .show_one_level(open=True)
#+END_SRC
** Handle mouse clicks to activate/select items
#+BEGIN_SRC python
  .item_activate(extend=True, recursive=False)
#+END_SRC
** Open all object entries and close all others
#+BEGIN_SRC python
  .show_hierarchy()
#+END_SRC
** Remove selected items (blue-gray rows) from active Keying Set
#+BEGIN_SRC python
  .keyingset_remove_selected()
#+END_SRC
** Rename item under cursor
#+BEGIN_SRC python
  .item_rename()
#+END_SRC
** Scroll page up or down
#+BEGIN_SRC python
  .scroll_page(up=False)
#+END_SRC
** Toggle the Outliner selection of items
#+BEGIN_SRC python
  .selected_toggle()
#+END_SRC
** Toggle the renderability of selected items
#+BEGIN_SRC python
  .renderability_toggle()
#+END_SRC
** Toggle the selectability
#+BEGIN_SRC python
  .selectability_toggle()
#+END_SRC
** Toggle the visibility of selected items
#+BEGIN_SRC python
  .visibility_toggle()
#+END_SRC
** Toggle whether item under cursor is enabled or closed
#+BEGIN_SRC python
  .item_openclose(all=True)
#+END_SRC
** Use box selection to select tree elements
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** animdata_operation
#+BEGIN_SRC python
  .animdata_operation(type='SET_ACT')
#+END_SRC
** data_operation
#+BEGIN_SRC python
  .data_operation(type='SELECT')
#+END_SRC
** group_operation
#+BEGIN_SRC python
  .group_operation(type='UNLINK')
#+END_SRC
** id_operation
#+BEGIN_SRC python
  .id_operation(type='UNLINK')
#+END_SRC
** object_operation
#+BEGIN_SRC python
  .object_operation(type='SELECT')
#+END_SRC
* bpy.ops.paint
** Add mask within the lasso as you move the pointer
#+BEGIN_SRC python
  .mask_lasso_gesture(path=[])
#+END_SRC
** Change selection for all faces
#+BEGIN_SRC python
  .face_select_all(action='TOGGLE')
#+END_SRC
** Change selection for all vertices
#+BEGIN_SRC python
  .vert_select_all(action='TOGGLE')
#+END_SRC
** Draw a line to apply a weight gradient to selected vertices
#+BEGIN_SRC python
  .weight_gradient(type='LINEAR', xstart=0, xend=0, ystart=0, yend=0, cursor=1002)
#+END_SRC
** Fill the active vertex color layer with the current paint color
#+BEGIN_SRC python
  .vertex_color_set()
#+END_SRC
** Fill the active vertex group with the current paint weight
#+BEGIN_SRC python
  .weight_set()
#+END_SRC
** Fill the whole mask with a given value, or invert its values
#+BEGIN_SRC python
  .mask_flood_fill(mode='VALUE', value=0)
#+END_SRC
** Hide selected faces
#+BEGIN_SRC python
  .face_select_hide(unselected=False)
#+END_SRC
** Hide/show some vertices
#+BEGIN_SRC python
  .hide_show(action='HIDE', area='INSIDE', xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** Make an image from the current 3D view for re-projection
#+BEGIN_SRC python
  .image_from_view(filepath="")
#+END_SRC
** Move the clone source image
#+BEGIN_SRC python
  .grab_clone(delta=(0, 0))
#+END_SRC
** Paint a stroke in the active vertex color layer
#+BEGIN_SRC python
  .vertex_paint(stroke=[])
#+END_SRC
** Paint a stroke in the current vertex group's weights
#+BEGIN_SRC python
  .weight_paint(stroke=[])
#+END_SRC
** Paint a stroke into the image
#+BEGIN_SRC python
  .image_paint(mode='NORMAL', stroke=[])
#+END_SRC
** Project an edited render from the active camera back onto the object
#+BEGIN_SRC python
  .project_image(image='<UNKNOWN ENUM>')
#+END_SRC
** Reveal hidden faces
#+BEGIN_SRC python
  .face_select_reveal(unselected=False)
#+END_SRC
** Select a paint mode's brush by tool type
#+BEGIN_SRC python
  .brush_select(paint_mode='ACTIVE', sculpt_tool='BLOB', vertex_paint_tool='MIX', weight_paint_tool='MIX', texture_paint_tool='DRAW', toggle=False, create_missing=False)
#+END_SRC
** Select linked faces
#+BEGIN_SRC python
  .face_select_linked()
#+END_SRC
** Select linked faces under the cursor
#+BEGIN_SRC python
  .face_select_linked_pick(deselect=False)
#+END_SRC
** Select one of the vertex groups available under current mouse position
#+BEGIN_SRC python
  .weight_sample_group(group='<UNKNOWN ENUM>')
#+END_SRC
** Select vertices without a group
#+BEGIN_SRC python
  .vert_select_ungrouped(extend=False)
#+END_SRC
** Set the weights of the groups matching the attached armature's selected bones, using the distance between the vertices and the bones
#+BEGIN_SRC python
  .weight_from_bones(type='AUTOMATIC')
#+END_SRC
** Smooth colors across vertices
#+BEGIN_SRC python
  .vertex_color_smooth()
#+END_SRC
** Toggle texture paint mode in 3D view
#+BEGIN_SRC python
  .texture_paint_toggle()
#+END_SRC
** Toggle the vertex paint mode in 3D view
#+BEGIN_SRC python
  .vertex_paint_toggle()
#+END_SRC
** Toggle weight paint mode in 3D view
#+BEGIN_SRC python
  .weight_paint_toggle()
#+END_SRC
** Use the mouse to sample a color in the image
#+BEGIN_SRC python
  .sample_color(location=(0, 0))
#+END_SRC
** Use the mouse to sample a weight in the 3D view
#+BEGIN_SRC python
  .weight_sample()
#+END_SRC
** vertex_color_dirt
#+BEGIN_SRC python
  .vertex_color_dirt(blur_strength=1, blur_iterations=1, clean_angle=3.14159, dirt_angle=0, dirt_only=False)
#+END_SRC
* bpy.ops.particle
** (De)select all particles' keys
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Add a new particle target
#+BEGIN_SRC python
  .new_target()
#+END_SRC
** Add new particle settings
#+BEGIN_SRC python
  .new()
#+END_SRC
** Apply a stroke of brush to the particles
#+BEGIN_SRC python
  .brush_edit(stroke=[])
#+END_SRC
** Change the number of keys of selected particles (root and tip keys included)
#+BEGIN_SRC python
  .rekey(keys_number=2)
#+END_SRC
** Connect hair to the emitter mesh
#+BEGIN_SRC python
  .connect_hair(all=False)
#+END_SRC
** Delete selected particles or keys
#+BEGIN_SRC python
  .delete(type='PARTICLE')
#+END_SRC
** Deselect boundary selected keys of each particle
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Disconnect hair from the emitter mesh
#+BEGIN_SRC python
  .disconnect_hair(all=False)
#+END_SRC
** Duplicate and mirror the selected particles along the local X axis
#+BEGIN_SRC python
  .mirror()
#+END_SRC
** Duplicate the current dupliobject
#+BEGIN_SRC python
  .dupliob_copy()
#+END_SRC
** Hide selected particles
#+BEGIN_SRC python
  .hide(unselected=False)
#+END_SRC
** Move dupli object down in the list
#+BEGIN_SRC python
  .dupliob_move_down()
#+END_SRC
** Move dupli object up in the list
#+BEGIN_SRC python
  .dupliob_move_up()
#+END_SRC
** Move particle target down in the list
#+BEGIN_SRC python
  .target_move_down()
#+END_SRC
** Move particle target up in the list
#+BEGIN_SRC python
  .target_move_up()
#+END_SRC
** Remove selected particles close enough of others
#+BEGIN_SRC python
  .remove_doubles(threshold=0.0002)
#+END_SRC
** Remove the selected dupliobject
#+BEGIN_SRC python
  .dupliob_remove()
#+END_SRC
** Remove the selected particle target
#+BEGIN_SRC python
  .target_remove()
#+END_SRC
** Select keys linked to boundary selected keys of each particle
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select nearest particle from mouse pointer
#+BEGIN_SRC python
  .select_linked(deselect=False, location=(0, 0))
#+END_SRC
** Select roots of all visible particles
#+BEGIN_SRC python
  .select_roots(action='SELECT')
#+END_SRC
** Select tips of all visible particles
#+BEGIN_SRC python
  .select_tips(action='SELECT')
#+END_SRC
** Set the weight of selected keys
#+BEGIN_SRC python
  .weight_set(factor=1)
#+END_SRC
** Show hidden particles
#+BEGIN_SRC python
  .reveal()
#+END_SRC
** Subdivide selected particles segments (adds keys)
#+BEGIN_SRC python
  .subdivide()
#+END_SRC
** Toggle particle edit mode
#+BEGIN_SRC python
  .particle_edit_toggle()
#+END_SRC
** Undo all edition performed on the particle system
#+BEGIN_SRC python
  .edited_clear()
#+END_SRC
* bpy.ops.pose
** Activate the bone with a flipped name
#+BEGIN_SRC python
  .select_flip_active()
#+END_SRC
** Add IK Constraint to the active Bone
#+BEGIN_SRC python
  .ik_add(with_targets=True)
#+END_SRC
** Add a constraint to the active bone
#+BEGIN_SRC python
  .constraint_add(type='<UNKNOWN ENUM>')
#+END_SRC
** Add a constraint to the active bone, with target (where applicable) set to the selected Objects/Bones
#+BEGIN_SRC python
  .constraint_add_with_targets(type='<UNKNOWN ENUM>')
#+END_SRC
** Add a new bone group
#+BEGIN_SRC python
  .group_add()
#+END_SRC
** Add selected bones to the chosen bone group
#+BEGIN_SRC python
  .group_assign(type=0)
#+END_SRC
** Apply final constrained position of pose bones to their transform
#+BEGIN_SRC python
  .visual_transform_apply()
#+END_SRC
** Apply the current pose as the new rest pose
#+BEGIN_SRC python
  .armature_apply()
#+END_SRC
** Automatically renames the selected bones according to which side of the target axis they fall on
#+BEGIN_SRC python
  .autoside_names(axis='XAXIS')
#+END_SRC
** Calculate paths for the selected bones
#+BEGIN_SRC python
  .paths_calculate(start_frame=1, end_frame=250, bake_location='TAILS')
#+END_SRC
** Change position of active Bone Group in list of Bone Groups
#+BEGIN_SRC python
  .group_move(direction='UP')
#+END_SRC
** Change the layers that the selected bones belong to
#+BEGIN_SRC python
  .bone_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Change the visible armature layers
#+BEGIN_SRC python
  .armature_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Clear all the constraints for the selected bones
#+BEGIN_SRC python
  .constraints_clear()
#+END_SRC
** Clear path caches for selected bones
#+BEGIN_SRC python
  .paths_clear()
#+END_SRC
** Copies the current pose of the selected bones to copy/paste buffer
#+BEGIN_SRC python
  .copy()
#+END_SRC
** Copy constraints to other selected bones
#+BEGIN_SRC python
  .constraints_copy()
#+END_SRC
** Copy selected aspects of the current pose to subsequent poses already keyframed
#+BEGIN_SRC python
  .propagate(mode='WHILE_HELD', end_frame=250)
#+END_SRC
** Create a suitable breakdown pose on the current frame
#+BEGIN_SRC python
  .breakdown(prev_frame=0, next_frame=0, percentage=0.5)
#+END_SRC
** Deselect bones of active Bone Group
#+BEGIN_SRC python
  .group_deselect()
#+END_SRC
** Exaggerate the current pose
#+BEGIN_SRC python
  .push(prev_frame=0, next_frame=0, percentage=0.5)
#+END_SRC
** Flip quaternion values to achieve desired rotations, while maintaining the same orientations
#+BEGIN_SRC python
  .quaternions_flip()
#+END_SRC
** Flips (and corrects) the axis suffixes of the the names of selected bones
#+BEGIN_SRC python
  .flip_names()
#+END_SRC
** Make the current pose more similar to its surrounding ones
#+BEGIN_SRC python
  .relax(prev_frame=0, next_frame=0, percentage=0.5)
#+END_SRC
** Paste the stored pose on to the current pose
#+BEGIN_SRC python
  .paste(flipped=False, selected_mask=False)
#+END_SRC
** Recalculate paths for bones that already have them
#+BEGIN_SRC python
  .paths_update()
#+END_SRC
** Remove all IK Constraints from selected bones
#+BEGIN_SRC python
  .ik_clear()
#+END_SRC
** Remove selected bones from all bone groups
#+BEGIN_SRC python
  .group_unassign()
#+END_SRC
** Remove the active bone group
#+BEGIN_SRC python
  .group_remove()
#+END_SRC
** Reset location, rotation, and scaling of selected bones to their default values
#+BEGIN_SRC python
  .transforms_clear()
#+END_SRC
** Reset locations of selected bones to their default values
#+BEGIN_SRC python
  .loc_clear()
#+END_SRC
** Reset pose on selected bones to keyframed state
#+BEGIN_SRC python
  .user_transforms_clear(only_selected=True)
#+END_SRC
** Reset rotations of selected bones to their default values
#+BEGIN_SRC python
  .rot_clear()
#+END_SRC
** Reset scaling of selected bones to their default values
#+BEGIN_SRC python
  .scale_clear()
#+END_SRC
** Select all visible bones grouped by similar properties
#+BEGIN_SRC python
  .select_grouped(extend=False, type='LAYER')
#+END_SRC
** Select bones in active Bone Group
#+BEGIN_SRC python
  .group_select()
#+END_SRC
** Select bones related to selected ones by parent/child relationships
#+BEGIN_SRC python
  .select_linked(extend=False)
#+END_SRC
** Select bones that are parents of the currently selected bones
#+BEGIN_SRC python
  .select_parent()
#+END_SRC
** Select bones used as targets for the currently selected bones
#+BEGIN_SRC python
  .select_constraint_target()
#+END_SRC
** Select immediate parent/children of selected bones
#+BEGIN_SRC python
  .select_hierarchy(direction='PARENT', extend=False)
#+END_SRC
** Set the rotation representation used by selected bones
#+BEGIN_SRC python
  .rotation_mode_set(type='QUATERNION')
#+END_SRC
** Sort Bone Groups by their names in ascending order
#+BEGIN_SRC python
  .group_sort()
#+END_SRC
** Tag selected bones to not be visible in Pose Mode
#+BEGIN_SRC python
  .hide(unselected=False)
#+END_SRC
** Toggle selection status of all bones
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Unhide all bones that have been tagged to be hidden in Pose Mode
#+BEGIN_SRC python
  .reveal()
#+END_SRC
* bpy.ops.poselib
** Add New Pose Library to active Object
#+BEGIN_SRC python
  .new()
#+END_SRC
** Add the current Pose to the active Pose Library
#+BEGIN_SRC python
  .pose_add(frame=1, name="Pose")
#+END_SRC
** Apply specified Pose Library pose to the rig
#+BEGIN_SRC python
  .apply_pose(pose_index=-1)
#+END_SRC
** Interactively browse poses in 3D-View
#+BEGIN_SRC python
  .browse_interactive(pose_index=-1)
#+END_SRC
** Make action suitable for use as a Pose Library
#+BEGIN_SRC python
  .action_sanitize()
#+END_SRC
** Remove Pose Library from active Object
#+BEGIN_SRC python
  .unlink()
#+END_SRC
** Remove nth pose from the active Pose Library
#+BEGIN_SRC python
  .pose_remove(pose='<UNKNOWN ENUM>')
#+END_SRC
** Rename specified pose from the active Pose Library
#+BEGIN_SRC python
  .pose_rename(name="RenamedPose", pose='<UNKNOWN ENUM>')
#+END_SRC
* bpy.ops.ptcache
** Add new cache
#+BEGIN_SRC python
  .add()
#+END_SRC
** Bake all physics
#+BEGIN_SRC python
  .bake_all(bake=True)
#+END_SRC
** Bake from cache
#+BEGIN_SRC python
  .bake_from_cache()
#+END_SRC
** Bake physics
#+BEGIN_SRC python
  .bake(bake=False)
#+END_SRC
** Delete current cache
#+BEGIN_SRC python
  .remove()
#+END_SRC
** Free all baked caches of all objects in the current scene
#+BEGIN_SRC python
  .free_bake_all()
#+END_SRC
** Free physics bake
#+BEGIN_SRC python
  .free_bake()
#+END_SRC
* bpy.ops.render
** Add a Render Preset
#+BEGIN_SRC python
  .preset_add(remove_active=False, name="")
#+END_SRC
** Add a Sampling Preset
#+BEGIN_SRC python
  .cycles_sampling_preset_add(remove_active=False, name="")
#+END_SRC
** Add an Integrator Preset
#+BEGIN_SRC python
  .cycles_integrator_preset_add(remove_active=False, name="")
#+END_SRC
** Cancel show render view
#+BEGIN_SRC python
  .view_cancel()
#+END_SRC
** OpenGL render active viewport
#+BEGIN_SRC python
  .opengl(animation=False, sequencer=False, write_still=False, view_context=True)
#+END_SRC
** Play back rendered frames/movies using an external player
#+BEGIN_SRC python
  .play_rendered_anim()
#+END_SRC
** Render active scene
#+BEGIN_SRC python
  .render(animation=False, write_still=False, use_viewport=False, layer="", scene="")
#+END_SRC
** Toggle show render view
#+BEGIN_SRC python
  .view_show()
#+END_SRC
* bpy.ops.rigidbody
** Add Rigid Body Constraint to active object
#+BEGIN_SRC python
  .constraint_add(type='FIXED')
#+END_SRC
** Add Rigid Body simulation world to the current scene
#+BEGIN_SRC python
  .world_add()
#+END_SRC
** Add active object as Rigid Body
#+BEGIN_SRC python
  .object_add(type='ACTIVE')
#+END_SRC
** Add selected objects as Rigid Bodies
#+BEGIN_SRC python
  .objects_add(type='ACTIVE')
#+END_SRC
** Automatically calculate mass values for Rigid Body Objects based on volume
#+BEGIN_SRC python
  .mass_calculate(material='Air', density=1)
#+END_SRC
** Bake rigid body transformations of selected objects to keyframes
#+BEGIN_SRC python
  .bake_to_keyframes(frame_start=1, frame_end=250, step=1)
#+END_SRC
** Change collision shapes for selected Rigid Body Objects
#+BEGIN_SRC python
  .shape_change(type='MESH')
#+END_SRC
** Copy Rigid Body settings from active object to selected
#+BEGIN_SRC python
  .object_settings_copy()
#+END_SRC
** Create rigid body constraints between selected rigid bodies
#+BEGIN_SRC python
  .connect(con_type='FIXED', pivot_type='CENTER', connection_pattern='SELECTED_TO_ACTIVE')
#+END_SRC
** Remove Rigid Body Constraint from Object
#+BEGIN_SRC python
  .constraint_remove()
#+END_SRC
** Remove Rigid Body settings from Object
#+BEGIN_SRC python
  .object_remove()
#+END_SRC
** Remove Rigid Body simulation world from the current scene
#+BEGIN_SRC python
  .world_remove()
#+END_SRC
** Remove selected objects from Rigid Body simulation
#+BEGIN_SRC python
  .objects_remove()
#+END_SRC
* bpy.ops.scene
** Add a line color modifier to the line style associated with the active lineset
#+BEGIN_SRC python
  .freestyle_color_modifier_add(type='ALONG_STROKE')
#+END_SRC
** Add a line set into the list of line sets
#+BEGIN_SRC python
  .freestyle_lineset_add()
#+END_SRC
** Add a line thickness modifier to the line style associated with the active lineset
#+BEGIN_SRC python
  .freestyle_thickness_modifier_add(type='ALONG_STROKE')
#+END_SRC
** Add a render layer
#+BEGIN_SRC python
  .render_layer_add()
#+END_SRC
** Add a stroke geometry modifier to the line style associated with the active lineset
#+BEGIN_SRC python
  .freestyle_geometry_modifier_add(type='2D_OFFSET')
#+END_SRC
** Add a style module into the list of modules
#+BEGIN_SRC python
  .freestyle_module_add()
#+END_SRC
** Add an alpha transparency modifier to the line style associated with the active lineset
#+BEGIN_SRC python
  .freestyle_alpha_modifier_add(type='ALONG_STROKE')
#+END_SRC
** Add new scene by type
#+BEGIN_SRC python
  .new(type='NEW')
#+END_SRC
** Add the data paths to the Freestyle Edge Mark property of selected edges to the active keying set
#+BEGIN_SRC python
  .freestyle_add_edge_marks_to_keying_set()
#+END_SRC
** Add the data paths to the Freestyle Face Mark property of selected polygons to the active keying set
#+BEGIN_SRC python
  .freestyle_add_face_marks_to_keying_set()
#+END_SRC
** Change the position of the active line set within the list of line sets
#+BEGIN_SRC python
  .freestyle_lineset_move(direction='UP')
#+END_SRC
** Change the position of the style module within in the list of style modules
#+BEGIN_SRC python
  .freestyle_module_move(direction='UP')
#+END_SRC
** Copy the active line set to a buffer
#+BEGIN_SRC python
  .freestyle_lineset_copy()
#+END_SRC
** Create a new line style, reusable by multiple line sets
#+BEGIN_SRC python
  .freestyle_linestyle_new()
#+END_SRC
** Delete active scene
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Duplicate the modifier within the list of modifiers
#+BEGIN_SRC python
  .freestyle_modifier_copy()
#+END_SRC
** Fill the Range Min/Max entries by the min/max distance between selected mesh objects and the source object
#+BEGIN_SRC python
  .freestyle_fill_range_by_selection(type='COLOR', name="")
#+END_SRC
** Move the modifier within the list of modifiers
#+BEGIN_SRC python
  .freestyle_modifier_move(direction='UP')
#+END_SRC
** Open a style module file
#+BEGIN_SRC python
  .freestyle_module_open(filepath="", make_internal=True)
#+END_SRC
** Paste the buffer content to the active line set
#+BEGIN_SRC python
  .freestyle_lineset_paste()
#+END_SRC
** Remove the active line set from the list of line sets
#+BEGIN_SRC python
  .freestyle_lineset_remove()
#+END_SRC
** Remove the modifier from the list of modifiers
#+BEGIN_SRC python
  .freestyle_modifier_remove()
#+END_SRC
** Remove the selected render layer
#+BEGIN_SRC python
  .render_layer_remove()
#+END_SRC
** Remove the style module from the stack
#+BEGIN_SRC python
  .freestyle_module_remove()
#+END_SRC
* bpy.ops.screen
** Add a new screen
#+BEGIN_SRC python
  .new()
#+END_SRC
** Blend in and out overlapping region
#+BEGIN_SRC python
  .region_blend()
#+END_SRC
** Cancel animation, returning to the original frame
#+BEGIN_SRC python
  .animation_cancel(restore_frame=True)
#+END_SRC
** Capture a picture of the active area or whole Blender window
#+BEGIN_SRC python
  .screenshot(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=True, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY', full=True)
#+END_SRC
** Capture a video of the active area or whole Blender window
#+BEGIN_SRC python
  .screencast(filepath="", full=True)
#+END_SRC
** Cycle through available screens
#+BEGIN_SRC python
  .screen_set(delta=0)
#+END_SRC
** Delete active screen
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Display header region toolbox
#+BEGIN_SRC python
  .header_toolbox()
#+END_SRC
** Display menu for last action performed
#+BEGIN_SRC python
  .redo_last()
#+END_SRC
** Display menu for previous actions performed
#+BEGIN_SRC python
  .repeat_history(index=0)
#+END_SRC
** Duplicate selected area into new window
#+BEGIN_SRC python
  .area_dupli()
#+END_SRC
** Handle area action zones for mouse actions/gestures
#+BEGIN_SRC python
  .actionzone(modifier=0)
#+END_SRC
** Join selected areas into new window
#+BEGIN_SRC python
  .area_join(min_x=-100, min_y=-100, max_x=-100, max_y=-100)
#+END_SRC
** Jump to first/last frame in frame range
#+BEGIN_SRC python
  .frame_jump(end=False)
#+END_SRC
** Jump to previous/next keyframe
#+BEGIN_SRC python
  .keyframe_jump(next=True)
#+END_SRC
** Jump to previous/next marker
#+BEGIN_SRC python
  .marker_jump(next=True)
#+END_SRC
** Move current frame forward/backward by a given number
#+BEGIN_SRC python
  .frame_offset(delta=0)
#+END_SRC
** Move selected area edges
#+BEGIN_SRC python
  .area_move(x=0, y=0, delta=0)
#+END_SRC
** Operations for splitting and merging
#+BEGIN_SRC python
  .area_options()
#+END_SRC
** Play animation
#+BEGIN_SRC python
  .animation_play(reverse=False, sync=False)
#+END_SRC
** Remove unused settings for invisible editors
#+BEGIN_SRC python
  .spacedata_cleanup()
#+END_SRC
** Repeat last action
#+BEGIN_SRC python
  .repeat_last()
#+END_SRC
** Revert back to the original screen layout, before fullscreen area overlay
#+BEGIN_SRC python
  .back_to_previous()
#+END_SRC
** Scale selected area
#+BEGIN_SRC python
  .region_scale()
#+END_SRC
** Show or hide the header pulldown menus
#+BEGIN_SRC python
  .header_toggle_menus()
#+END_SRC
** Show user preferences
#+BEGIN_SRC python
  .userpref_show()
#+END_SRC
** Split selected area into camera, front, right & top views
#+BEGIN_SRC python
  .region_quadview()
#+END_SRC
** Split selected area into new windows
#+BEGIN_SRC python
  .area_split(direction='HORIZONTAL', factor=0.5, mouse_x=-100, mouse_y=-100)
#+END_SRC
** Step through animation by position
#+BEGIN_SRC python
  .animation_step()
#+END_SRC
** Swap selected areas screen positions
#+BEGIN_SRC python
  .area_swap()
#+END_SRC
** Toggle display selected area as fullscreen
#+BEGIN_SRC python
  .screen_full_area()
#+END_SRC
** Toggle the header over/below the main window area
#+BEGIN_SRC python
  .header_flip()
#+END_SRC
** Toggle the region's alignment (left/right or top/bottom)
#+BEGIN_SRC python
  .region_flip()
#+END_SRC
* bpy.ops.script
** Execute a preset
#+BEGIN_SRC python
  .execute_preset(filepath="", menu_idname="")
#+END_SRC
** Ignore autoexec warning
#+BEGIN_SRC python
  .autoexec_warn_clear()
#+END_SRC
** Reload Scripts
#+BEGIN_SRC python
  .reload()
#+END_SRC
** Run Python file
#+BEGIN_SRC python
  .python_file_run(filepath="")
#+END_SRC
* bpy.ops.sculpt
** Dynamic topology alters the mesh topology while sculpting
#+BEGIN_SRC python
  .dynamic_topology_toggle()
#+END_SRC
** Recalculate the sculpt BVH to improve performance
#+BEGIN_SRC python
  .optimize()
#+END_SRC
** Reset the copy of the mesh that is being sculpted on
#+BEGIN_SRC python
  .set_persistent_base()
#+END_SRC
** Sculpt UVs using a brush
#+BEGIN_SRC python
  .uv_sculpt_stroke(mode='NORMAL')
#+END_SRC
** Sculpt a stroke into the geometry
#+BEGIN_SRC python
  .brush_stroke(stroke=[], mode='NORMAL', ignore_background_click=False)
#+END_SRC
** Symmetrize the topology modifications
#+BEGIN_SRC python
  .symmetrize()
#+END_SRC
** Toggle sculpt mode in 3D view
#+BEGIN_SRC python
  .sculptmode_toggle()
#+END_SRC
* bpy.ops.sequencer
** Add a mask strip to the sequencer
#+BEGIN_SRC python
  .mask_strip_add(frame_start=0, channel=1, replace_sel=True, overlap=False, mask='<UNKNOWN ENUM>')
#+END_SRC
** Add a modifier to the strip
#+BEGIN_SRC python
  .strip_modifier_add(type='COLOR_BALANCE')
#+END_SRC
** Add a movie strip to the sequencer
#+BEGIN_SRC python
  .movie_strip_add(filepath="", files=[], filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', frame_start=0, channel=1, replace_sel=True, overlap=False, sound=True)
#+END_SRC
** Add a movieclip strip to the sequencer
#+BEGIN_SRC python
  .movieclip_strip_add(frame_start=0, channel=1, replace_sel=True, overlap=False, clip='<UNKNOWN ENUM>')
#+END_SRC
** Add a sound strip to the sequencer
#+BEGIN_SRC python
  .sound_strip_add(filepath="", files=[], filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', frame_start=0, channel=1, replace_sel=True, overlap=False, cache=False)
#+END_SRC
** Add a strip to the sequencer using a blender scene as a source
#+BEGIN_SRC python
  .scene_strip_add(frame_start=0, channel=1, replace_sel=True, overlap=False, scene='Scene')
#+END_SRC
** Add an effect to the sequencer, most are applied on top of existing strips
#+BEGIN_SRC python
  .effect_strip_add(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=False, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', frame_start=0, frame_end=0, channel=1, replace_sel=True, overlap=False, type='CROSS', color=(0, 0, 0))
#+END_SRC
** Add an image or image sequence to the sequencer
#+BEGIN_SRC python
  .image_strip_add(directory="", files=[], filter_blender=False, filter_backup=False, filter_image=True, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', frame_start=0, frame_end=0, channel=1, replace_sel=True, overlap=False)
#+END_SRC
** Change zoom ratio of sequencer preview
#+BEGIN_SRC python
  .view_zoom_ratio(ratio=1)
#+END_SRC
** Clear strip offsets from the start and end frames
#+BEGIN_SRC python
  .offset_clear()
#+END_SRC
** Cut multi-cam strip and select camera
#+BEGIN_SRC python
  .cut_multicam(camera=1)
#+END_SRC
** Cut the selected strips
#+BEGIN_SRC python
  .cut(frame=0, type='SOFT', side='BOTH')
#+END_SRC
** Deinterlace all selected movie sources
#+BEGIN_SRC python
  .deinterlace_selected_movies()
#+END_SRC
** Do cross-fading volume animation of two selected sound strips
#+BEGIN_SRC python
  .crossfade_sounds()
#+END_SRC
** Duplicate selected strips and move them
#+BEGIN_SRC python
  .duplicate_move(SEQUENCER_OT_duplicate={"mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "texture_space":False, "remove_on_cancel":False, "release_confirm":False})
#+END_SRC
** Duplicate the selected strips
#+BEGIN_SRC python
  .duplicate(mode='TRANSLATION')
#+END_SRC
** Erase selected strips from the sequencer
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Frame where selected strips will be snapped
#+BEGIN_SRC python
  .snap(frame=0)
#+END_SRC
** Group selected strips into a metastrip
#+BEGIN_SRC python
  .meta_make()
#+END_SRC
** Insert gap at current frame to first strips at the right, independent of selection or locked state of strips
#+BEGIN_SRC python
  .gap_insert(frames=10)
#+END_SRC
** Lock the active strip so that it can't be transformed
#+BEGIN_SRC python
  .lock()
#+END_SRC
** Move frame to previous edit point
#+BEGIN_SRC python
  .strip_jump(next=True, center=True)
#+END_SRC
** Move modifier up and down in the stack
#+BEGIN_SRC python
  .strip_modifier_move(name="Name", direction='UP')
#+END_SRC
** Mute selected strips
#+BEGIN_SRC python
  .mute(unselected=False)
#+END_SRC
** On image sequence strips, it returns a strip for each image
#+BEGIN_SRC python
  .images_separate(length=1)
#+END_SRC
** Open sequencer properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Put the contents of a metastrip back in the sequencer
#+BEGIN_SRC python
  .meta_separate()
#+END_SRC
** Reassign the inputs for the effect strip
#+BEGIN_SRC python
  .reassign_inputs()
#+END_SRC
** Rebuild all selected proxies and timecode indices using the job system
#+BEGIN_SRC python
  .rebuild_proxy()
#+END_SRC
** Refresh the sequencer editor
#+BEGIN_SRC python
  .refresh_all()
#+END_SRC
** Reload strips in the sequencer
#+BEGIN_SRC python
  .reload(adjust_length=False)
#+END_SRC
** Remove a modifier from the strip
#+BEGIN_SRC python
  .strip_modifier_remove(name="Name")
#+END_SRC
** Remove gap at current frame to first strip at the right, independent of selection or locked state of strips
#+BEGIN_SRC python
  .gap_remove(all=False)
#+END_SRC
** Select a chain of linked strips nearest to the mouse pointer
#+BEGIN_SRC python
  .select_linked_pick(extend=False)
#+END_SRC
** Select a strip (last selected becomes the "active strip")
#+BEGIN_SRC python
  .select(extend=False, linked_handle=False, left_right=False, linked_time=False)
#+END_SRC
** Select all strips adjacent to the current selection
#+BEGIN_SRC python
  .select_linked()
#+END_SRC
** Select all strips grouped by various properties
#+BEGIN_SRC python
  .select_grouped(extend=False, type='TYPE')
#+END_SRC
** Select manipulator handles on the sides of the selected strip
#+BEGIN_SRC python
  .select_handles(side='BOTH')
#+END_SRC
** Select more strips adjacent to the current selection
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select or deselect all strips
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Select strips on the nominated side of the active strip
#+BEGIN_SRC python
  .select_active_side(side='BOTH')
#+END_SRC
** Select strips using border selection
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Set render size and aspect from active sequence
#+BEGIN_SRC python
  .rendersize()
#+END_SRC
** Set the boundaries of the border used for offset-view
#+BEGIN_SRC python
  .view_ghost_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** Shrink the current selection of adjacent selected strips
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Swap 2 sequencer strips
#+BEGIN_SRC python
  .swap_data()
#+END_SRC
** Swap active strip with strip to the right or left
#+BEGIN_SRC python
  .swap(side='RIGHT')
#+END_SRC
** Swap the first two inputs for the effect strip
#+BEGIN_SRC python
  .swap_inputs()
#+END_SRC
** Toggle a metastrip (to edit enclosed strips)
#+BEGIN_SRC python
  .meta_toggle()
#+END_SRC
** Toggle between sequencer views (sequence, preview, both)
#+BEGIN_SRC python
  .view_toggle()
#+END_SRC
** Un-Mute unselected rather than selected strips
#+BEGIN_SRC python
  .unmute(unselected=False)
#+END_SRC
** Unlock the active strip so that it can't be transformed
#+BEGIN_SRC python
  .unlock()
#+END_SRC
** Use mouse to sample color in current frame
#+BEGIN_SRC python
  .sample()
#+END_SRC
** View all the strips in the sequencer
#+BEGIN_SRC python
  .view_all()
#+END_SRC
** Zoom preview to fit in the area
#+BEGIN_SRC python
  .view_all_preview()
#+END_SRC
** Zoom the sequencer on the selected strips
#+BEGIN_SRC python
  .view_selected()
#+END_SRC
** change_effect_input
#+BEGIN_SRC python
  .change_effect_input(swap='A_B')
#+END_SRC
** change_effect_type
#+BEGIN_SRC python
  .change_effect_type(type='CROSS')
#+END_SRC
** change_path
#+BEGIN_SRC python
  .change_path(filepath="", directory="", files=[], filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** copy
#+BEGIN_SRC python
  .copy()
#+END_SRC
** paste
#+BEGIN_SRC python
  .paste()
#+END_SRC
* bpy.ops.sketch
** Cancel the current sketch stroke
#+BEGIN_SRC python
  .cancel_stroke()
#+END_SRC
** Convert the selected sketch strokes to bone chains
#+BEGIN_SRC python
  .convert()
#+END_SRC
** Delete a sketch stroke
#+BEGIN_SRC python
  .delete()
#+END_SRC
** Draw preview of current sketch stroke (internal use)
#+BEGIN_SRC python
  .draw_preview(snap=False)
#+END_SRC
** End and keep the current sketch stroke
#+BEGIN_SRC python
  .finish_stroke()
#+END_SRC
** Select a sketch stroke
#+BEGIN_SRC python
  .select()
#+END_SRC
** Start to draw a gesture stroke
#+BEGIN_SRC python
  .gesture(snap=False)
#+END_SRC
** Start to draw a sketch stroke
#+BEGIN_SRC python
  .draw_stroke(snap=False)
#+END_SRC
* bpy.ops.sound
** Load a sound file
#+BEGIN_SRC python
  .open(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', cache=False, mono=False)
#+END_SRC
** Load a sound file as mono
#+BEGIN_SRC python
  .open_mono(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', cache=False, mono=True)
#+END_SRC
** Mixes the scene's audio to a sound file
#+BEGIN_SRC python
  .mixdown(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, relative_path=True, display_type='FILE_DEFAULTDISPLAY', accuracy=1024, container='FLAC', codec='FLAC', format='S16', bitrate=192, split_channels=False)
#+END_SRC
** Pack the sound into the current blend file
#+BEGIN_SRC python
  .pack()
#+END_SRC
** Unpack the sound to the samples filename
#+BEGIN_SRC python
  .unpack(method='USE_LOCAL', id="")
#+END_SRC
** Update animation flags
#+BEGIN_SRC python
  .update_animation_flags()
#+END_SRC
** Update the audio animation cache
#+BEGIN_SRC python
  .bake_animation()
#+END_SRC
* bpy.ops.surface
** Construct a Nurbs surface Circle
#+BEGIN_SRC python
  .primitive_nurbs_surface_circle_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs surface Curve
#+BEGIN_SRC python
  .primitive_nurbs_surface_curve_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs surface Cylinder
#+BEGIN_SRC python
  .primitive_nurbs_surface_cylinder_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs surface Patch
#+BEGIN_SRC python
  .primitive_nurbs_surface_surface_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs surface Sphere
#+BEGIN_SRC python
  .primitive_nurbs_surface_sphere_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
** Construct a Nurbs surface Torus
#+BEGIN_SRC python
  .primitive_nurbs_surface_torus_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#+END_SRC
* bpy.ops.text
** Convert selected comment to text
#+BEGIN_SRC python
  .uncomment()
#+END_SRC
** Convert selected text to comment
#+BEGIN_SRC python
  .comment()
#+END_SRC
** Convert whitespaces by type
#+BEGIN_SRC python
  .convert_whitespace(type='SPACES')
#+END_SRC
** Copy selected text to clipboard
#+BEGIN_SRC python
  .copy()
#+END_SRC
** Create 3D text object from active text data block
#+BEGIN_SRC python
  .to_3d_object(split_lines=False)
#+END_SRC
** Create a new text data block
#+BEGIN_SRC python
  .new()
#+END_SRC
** Cut selected text to clipboard
#+BEGIN_SRC python
  .cut()
#+END_SRC
** Delete text by cursor position
#+BEGIN_SRC python
  .delete(type='NEXT_CHARACTER')
#+END_SRC
** Duplicate the current line
#+BEGIN_SRC python
  .duplicate_line()
#+END_SRC
** Find specified text
#+BEGIN_SRC python
  .find()
#+END_SRC
** Find specified text and set as selected
#+BEGIN_SRC python
  .find_set_selected()
#+END_SRC
** Indent selected text
#+BEGIN_SRC python
  .indent()
#+END_SRC
** Insert line break at cursor position
#+BEGIN_SRC python
  .line_break()
#+END_SRC
** Insert text at cursor position
#+BEGIN_SRC python
  .insert(text="")
#+END_SRC
** Jump cursor to line
#+BEGIN_SRC python
  .jump(line=1)
#+END_SRC
** Make active text file internal
#+BEGIN_SRC python
  .make_internal()
#+END_SRC
** Move cursor to position type
#+BEGIN_SRC python
  .move(type='LINE_BEGIN')
#+END_SRC
** Move the currently selected line(s) up/down
#+BEGIN_SRC python
  .move_lines(direction='DOWN')
#+END_SRC
** Move the cursor while selecting
#+BEGIN_SRC python
  .move_select(type='LINE_BEGIN')
#+END_SRC
** Open a new text data block
#+BEGIN_SRC python
  .open(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=True, filter_font=False, filter_sound=False, filter_text=True, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY', internal=False)
#+END_SRC
** Paste text from clipboard
#+BEGIN_SRC python
  .paste(selection=False)
#+END_SRC
** Refresh all pyconstraints
#+BEGIN_SRC python
  .refresh_pyconstraints()
#+END_SRC
** Reload active text data block from its file
#+BEGIN_SRC python
  .reload()
#+END_SRC
** Replace text with specified text and set as selected
#+BEGIN_SRC python
  .replace_set_selected()
#+END_SRC
** Replace text with the specified text
#+BEGIN_SRC python
  .replace()
#+END_SRC
** Run active script
#+BEGIN_SRC python
  .run_script()
#+END_SRC
** Save active text data block
#+BEGIN_SRC python
  .save()
#+END_SRC
** Save active text file with options
#+BEGIN_SRC python
  .save_as(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=True, filter_font=False, filter_sound=False, filter_text=True, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
** Select all text
#+BEGIN_SRC python
  .select_all()
#+END_SRC
** Select text by line
#+BEGIN_SRC python
  .select_line()
#+END_SRC
** Select word under cursor
#+BEGIN_SRC python
  .select_word()
#+END_SRC
** Set cursor position
#+BEGIN_SRC python
  .cursor_set(x=0, y=0)
#+END_SRC
** Set cursor selection
#+BEGIN_SRC python
  .selection_set(select=False)
#+END_SRC
** Show a list of used text in the open document
#+BEGIN_SRC python
  .autocomplete()
#+END_SRC
** Start searching text
#+BEGIN_SRC python
  .start_find()
#+END_SRC
** The current line number
#+BEGIN_SRC python
  .line_number()
#+END_SRC
** Toggle overwrite while typing
#+BEGIN_SRC python
  .overwrite_toggle()
#+END_SRC
** Toggle text properties panel
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Unindent selected text
#+BEGIN_SRC python
  .unindent()
#+END_SRC
** Unlink active text data block
#+BEGIN_SRC python
  .unlink()
#+END_SRC
** When external text is out of sync, resolve the conflict
#+BEGIN_SRC python
  .resolve_conflict(resolution='IGNORE')
#+END_SRC
** scroll
#+BEGIN_SRC python
  .scroll(lines=1)
#+END_SRC
** scroll_bar
#+BEGIN_SRC python
  .scroll_bar(lines=1)
#+END_SRC
* bpy.ops.texture
** Add a new texture
#+BEGIN_SRC python
  .new()
#+END_SRC
** Copy the material texture settings and nodes
#+BEGIN_SRC python
  .slot_copy()
#+END_SRC
** Copy the texture settings and nodes
#+BEGIN_SRC python
  .slot_paste()
#+END_SRC
** Discard all environment maps in the .blend file and free them from memory
#+BEGIN_SRC python
  .envmap_clear_all()
#+END_SRC
** Discard the environment map and free it from memory
#+BEGIN_SRC python
  .envmap_clear()
#+END_SRC
** Move texture slots up and down
#+BEGIN_SRC python
  .slot_move(type='UP')
#+END_SRC
** Save the current generated Environment map to an image file
#+BEGIN_SRC python
  .envmap_save(layout=(0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1), filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=9, display_type='FILE_DEFAULTDISPLAY')
#+END_SRC
* bpy.ops.time
** Set the end frame
#+BEGIN_SRC python
  .end_frame_set()
#+END_SRC
** Set the start frame
#+BEGIN_SRC python
  .start_frame_set()
#+END_SRC
** Show the entire playable frame range
#+BEGIN_SRC python
  .view_all()
#+END_SRC
* bpy.ops.transform
** Change the bevel weight of edges
#+BEGIN_SRC python
  .edge_bevelweight(value=0, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Change the crease of edges
#+BEGIN_SRC python
  .edge_crease(value=0, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Create transformation orientation from selection
#+BEGIN_SRC python
  .create_orientation(name="", use_view=False, use=False, overwrite=False)
#+END_SRC
** Delete transformation orientation
#+BEGIN_SRC python
  .delete_orientation()
#+END_SRC
** Mirror selected vertices around one or more axes
#+BEGIN_SRC python
  .mirror(constraint_axis=(False, False, False), constraint_orientation='GLOBAL', proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, release_confirm=False)
#+END_SRC
** Move selected vertices outward in a spherical shape around mesh center
#+BEGIN_SRC python
  .tosphere(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Push/Pull selected items
#+BEGIN_SRC python
  .push_pull(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Rotate selected items
#+BEGIN_SRC python
  .rotate(value=0, axis=(0, 0, 0), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Scale (resize) selected items
#+BEGIN_SRC python
  .resize(value=(1, 1, 1), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), texture_space=False, remove_on_cancel=False, release_confirm=False)
#+END_SRC
** Scale selected vertices' skin radii
#+BEGIN_SRC python
  .skin_resize(value=(1, 1, 1), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), texture_space=False, remove_on_cancel=False, release_confirm=False)
#+END_SRC
** Select transformation orientation
#+BEGIN_SRC python
  .select_orientation(orientation='GLOBAL')
#+END_SRC
** Shear selected items along the horizontal screen axis
#+BEGIN_SRC python
  .shear(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Shrink/fatten selected vertices along normals
#+BEGIN_SRC python
  .shrink_fatten(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Slide a sequence strip in time
#+BEGIN_SRC python
  .seq_slide(value=(0, 0), snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Slide a vertex along a mesh
#+BEGIN_SRC python
  .vert_slide(value=0, mirror=False, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Slide an edge loop along a mesh
#+BEGIN_SRC python
  .edge_slide(value=0, mirror=False, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), correct_uv=False, release_confirm=False)
#+END_SRC
** Tilt selected control vertices of 3D curve
#+BEGIN_SRC python
  .tilt(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Trackball style rotation of selected items
#+BEGIN_SRC python
  .trackball(value=(0, 0), mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Transform selected items by mode type
#+BEGIN_SRC python
  .transform(mode='TRANSLATION', value=(0, 0, 0, 0), axis=(0, 0, 0), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
** Translate (move) selected items
#+BEGIN_SRC python
  .translate(value=(0, 0, 0), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), texture_space=False, remove_on_cancel=False, release_confirm=False)
#+END_SRC
** Warp selected items around the cursor
#+BEGIN_SRC python
  .warp(value=(0,), mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False)
#+END_SRC
* bpy.ops.ui
** Clear the property and use default or generated value in operators
#+BEGIN_SRC python
  .unset_property_button()
#+END_SRC
** Copy property from this object to selected objects or bones
#+BEGIN_SRC python
  .copy_to_selected_button(all=True)
#+END_SRC
** Copy the RNA data path for this property to the clipboard
#+BEGIN_SRC python
  .copy_data_path_button()
#+END_SRC
** Edit UI source code of the active button
#+BEGIN_SRC python
  .editsource()
#+END_SRC
** Edit i18n in current language for the active button
#+BEGIN_SRC python
  .edittranslation_init()
#+END_SRC
** Force a full reload of UI translation
#+BEGIN_SRC python
  .reloadtranslation()
#+END_SRC
** Reset this property's value to its default value
#+BEGIN_SRC python
  .reset_default_button(all=True)
#+END_SRC
** Reset to the default theme colors
#+BEGIN_SRC python
  .reset_default_theme()
#+END_SRC
** Sample a color from the Blender Window to store in a property
#+BEGIN_SRC python
  .eyedropper_color()
#+END_SRC
** Sample a color from the Blender Window to store in a property
#+BEGIN_SRC python
  .eyedropper_id()
#+END_SRC
** Write the reports
#+BEGIN_SRC python
  .reports_to_textblock()
#+END_SRC
* bpy.ops.uv
** Align selected UV vertices to an axis
#+BEGIN_SRC python
  .align(axis='ALIGN_AUTO')
#+END_SRC
** Average the size of separate UV islands, based on their area in 3D space
#+BEGIN_SRC python
  .average_islands_scale()
#+END_SRC
** Change selection of all UV vertices
#+BEGIN_SRC python
  .select_all(action='TOGGLE')
#+END_SRC
** Deselect UV vertices at the boundary of each selection region
#+BEGIN_SRC python
  .select_less()
#+END_SRC
** Export UV layout to file
#+BEGIN_SRC python
  .export_layout(filepath="", check_existing=True, export_all=False, modified=False, mode='PNG', size=(1024, 1024), opacity=0.25, tessellated=False)
#+END_SRC
** Follow UVs from active quads along continuous face loops
#+BEGIN_SRC python
  .follow_active_quads(mode='LENGTH_AVERAGE')
#+END_SRC
** Hide (un)selected UV vertices
#+BEGIN_SRC python
  .hide(unselected=False)
#+END_SRC
** Mark selected UV edges as seams
#+BEGIN_SRC python
  .mark_seam()
#+END_SRC
** Pack each faces UV's into the UV bounds
#+BEGIN_SRC python
  .lightmap_pack(PREF_CONTEXT='SEL_FACES', PREF_PACK_IN_ONE=True, PREF_NEW_UVLAYER=False, PREF_APPLY_IMAGE=False, PREF_IMG_PX_SIZE=512, PREF_BOX_DIV=12, PREF_MARGIN_DIV=0.1)
#+END_SRC
** Project the UV vertices of the mesh as seen in current 3D view
#+BEGIN_SRC python
  .project_from_view(orthographic=False, camera_bounds=True, correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
#+END_SRC
** Project the UV vertices of the mesh over the curved surface of a sphere
#+BEGIN_SRC python
  .sphere_project(direction='VIEW_ON_EQUATOR', align='POLAR_ZX', correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
#+END_SRC
** Project the UV vertices of the mesh over the curved wall of a cylinder
#+BEGIN_SRC python
  .cylinder_project(direction='VIEW_ON_EQUATOR', align='POLAR_ZX', radius=1, correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
#+END_SRC
** Project the UV vertices of the mesh over the six faces of a cube
#+BEGIN_SRC python
  .cube_project(cube_size=1, correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
#+END_SRC
** Reduce UV stretching by relaxing angles
#+BEGIN_SRC python
  .minimize_stretch(fill_holes=True, blend=0, iterations=0)
#+END_SRC
** Reset UV projection
#+BEGIN_SRC python
  .reset()
#+END_SRC
** Reveal all hidden UV vertices
#+BEGIN_SRC python
  .reveal()
#+END_SRC
** Select UV vertices
#+BEGIN_SRC python
  .select(extend=False, location=(0, 0))
#+END_SRC
** Select UV vertices using border selection
#+BEGIN_SRC python
  .select_border(pinned=False, gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Select UV vertices using circle selection
#+BEGIN_SRC python
  .circle_select(x=0, y=0, radius=0, gesture_mode=0)
#+END_SRC
** Select UVs using lasso selection
#+BEGIN_SRC python
  .select_lasso(path=[], deselect=False, extend=True)
#+END_SRC
** Select a loop of connected UV vertices
#+BEGIN_SRC python
  .select_loop(extend=False, location=(0, 0))
#+END_SRC
** Select all UV vertices linked to the active UV map
#+BEGIN_SRC python
  .select_linked(extend=False)
#+END_SRC
** Select all UV vertices linked under the mouse
#+BEGIN_SRC python
  .select_linked_pick(extend=False, location=(0, 0))
#+END_SRC
** Select all pinned UV vertices
#+BEGIN_SRC python
  .select_pinned()
#+END_SRC
** Select more UV vertices connected to initial selection
#+BEGIN_SRC python
  .select_more()
#+END_SRC
** Select only entirely selected faces
#+BEGIN_SRC python
  .select_split()
#+END_SRC
** Selected UV vertices that are within a radius of each other are welded together
#+BEGIN_SRC python
  .remove_doubles(threshold=0.02, use_unselected=False)
#+END_SRC
** Set 2D cursor location
#+BEGIN_SRC python
  .cursor_set(location=(0, 0))
#+END_SRC
** Set UV image tile coordinates
#+BEGIN_SRC python
  .tile_set(tile=(0, 0))
#+END_SRC
** Set mesh seams according to island setup in the UV editor
#+BEGIN_SRC python
  .seams_from_islands(mark_seams=True, mark_sharp=False)
#+END_SRC
** Set/clear selected UV vertices as anchored between multiple unwrap operations
#+BEGIN_SRC python
  .pin(clear=False)
#+END_SRC
** Snap cursor to target type
#+BEGIN_SRC python
  .snap_cursor(target='PIXELS')
#+END_SRC
** Snap selected UV vertices to target type
#+BEGIN_SRC python
  .snap_selected(target='PIXELS')
#+END_SRC
** Stitch selected UV vertices by proximity
#+BEGIN_SRC python
  .stitch(use_limit=False, snap_islands=True, limit=0.01, static_island=0, midpoint_snap=False, clear_seams=True, mode='VERTEX', stored_mode='VERTEX', selection=[])
#+END_SRC
** This script projection unwraps the selected faces of a mesh (it operates on all selected mesh objects, and can be used to unwrap selected faces, or all faces)
#+BEGIN_SRC python
  .smart_project(angle_limit=66, island_margin=0, user_area_weight=0)
#+END_SRC
** Transform all islands so that they fill up the UV space as much as possible
#+BEGIN_SRC python
  .pack_islands(rotate=True, margin=0.001)
#+END_SRC
** Unwrap the mesh of the object being edited
#+BEGIN_SRC python
  .unwrap(method='ANGLE_BASED', fill_holes=True, correct_aspect=True, use_subsurf_data=False, margin=0.001)
#+END_SRC
** Weld selected UV vertices together
#+BEGIN_SRC python
  .weld()
#+END_SRC
* bpy.ops.view2d
** Pan the view
#+BEGIN_SRC python
  .pan(deltax=0, deltay=0)
#+END_SRC
** Reset the view
#+BEGIN_SRC python
  .reset()
#+END_SRC
** Scroll the view down
#+BEGIN_SRC python
  .scroll_down(deltax=0, deltay=0, page=False)
#+END_SRC
** Scroll the view left
#+BEGIN_SRC python
  .scroll_left(deltax=0, deltay=0)
#+END_SRC
** Scroll the view right
#+BEGIN_SRC python
  .scroll_right(deltax=0, deltay=0)
#+END_SRC
** Scroll the view up
#+BEGIN_SRC python
  .scroll_up(deltax=0, deltay=0, page=False)
#+END_SRC
** Scroll view by mouse click and drag
#+BEGIN_SRC python
  .scroller_activate()
#+END_SRC
** Zoom in the view
#+BEGIN_SRC python
  .zoom_in(zoomfacx=0, zoomfacy=0)
#+END_SRC
** Zoom in the view to the nearest item contained in the border
#+BEGIN_SRC python
  .zoom_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** Zoom in/out the view
#+BEGIN_SRC python
  .zoom(deltax=0, deltay=0)
#+END_SRC
** Zoom out the view
#+BEGIN_SRC python
  .zoom_out(zoomfacx=0, zoomfacy=0)
#+END_SRC
** smoothview
#+BEGIN_SRC python
  .smoothview(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
* bpy.ops.view3d
** Activate/select item(s)
#+BEGIN_SRC python
  .select(extend=False, deselect=False, toggle=False, center=False, enumerate=False, object=False, location=(0, 0))
#+END_SRC
** Add a new background image
#+BEGIN_SRC python
  .background_image_add(name="Image", filepath="Path")
#+END_SRC
** Center the camera view
#+BEGIN_SRC python
  .view_center_camera()
#+END_SRC
** Center the view lock offset
#+BEGIN_SRC python
  .view_center_lock()
#+END_SRC
** Center the view so that the cursor is in the middle of the view
#+BEGIN_SRC python
  .view_center_cursor()
#+END_SRC
** Center the view to the Z-depth position under the mouse cursor
#+BEGIN_SRC python
  .view_center_pick()
#+END_SRC
** Clear all view locking
#+BEGIN_SRC python
  .view_lock_clear()
#+END_SRC
** Clear the boundaries of the border render and disable border render
#+BEGIN_SRC python
  .clear_render_border()
#+END_SRC
** Contents of copy buffer gets pasted
#+BEGIN_SRC python
  .pastebuffer()
#+END_SRC
** Dolly in/out in the view
#+BEGIN_SRC python
  .dolly(delta=0, mx=0, my=0)
#+END_SRC
** Enable the transform manipulator for use
#+BEGIN_SRC python
  .enable_manipulator(translate=False, rotate=False, scale=False)
#+END_SRC
** Extrude and move along individual normals
#+BEGIN_SRC python
  .edit_mesh_extrude_move_shrink_fatten()
#+END_SRC
** Extrude and move along normals
#+BEGIN_SRC python
  .edit_mesh_extrude_move_normal()
#+END_SRC
** Extrude individual elements and move
#+BEGIN_SRC python
  .edit_mesh_extrude_individual_move()
#+END_SRC
** Interactive ruler
#+BEGIN_SRC python
  .ruler()
#+END_SRC
** Interactively fly around the scene
#+BEGIN_SRC python
  .fly()
#+END_SRC
** Lock the view to the active object/bone
#+BEGIN_SRC python
  .view_lock_to_active()
#+END_SRC
** Manipulate selected item by axis
#+BEGIN_SRC python
  .manipulator(constraint_axis=(False, False, False), constraint_orientation='GLOBAL', release_confirm=False)
#+END_SRC
** Match the camera to 1:1 to the render output
#+BEGIN_SRC python
  .zoom_camera_1_to_1()
#+END_SRC
** Menu object selection
#+BEGIN_SRC python
  .select_menu(name='<UNKNOWN ENUM>', toggle=False)
#+END_SRC
** Move the camera so selected objects are framed
#+BEGIN_SRC python
  .camera_to_view_selected()
#+END_SRC
** Move the view
#+BEGIN_SRC python
  .move()
#+END_SRC
** Move the view to the selection center
#+BEGIN_SRC python
  .view_selected(use_all_regions=False)
#+END_SRC
** Orbit and zoom the view using the 3D mouse
#+BEGIN_SRC python
  .ndof_orbit_zoom()
#+END_SRC
** Orbit the view
#+BEGIN_SRC python
  .view_orbit(type='ORBITLEFT')
#+END_SRC
** Orbit the view using the 3D mouse
#+BEGIN_SRC python
  .ndof_orbit()
#+END_SRC
** Pan and rotate the view with the 3D mouse
#+BEGIN_SRC python
  .ndof_all()
#+END_SRC
** Pan the view
#+BEGIN_SRC python
  .view_pan(type='PANLEFT')
#+END_SRC
** Pan the view with the 3D mouse
#+BEGIN_SRC python
  .ndof_pan()
#+END_SRC
** Remove a background image from the 3D view
#+BEGIN_SRC python
  .background_image_remove(index=0)
#+END_SRC
** Roll the view
#+BEGIN_SRC python
  .view_roll(angle=0)
#+END_SRC
** Rotate the view
#+BEGIN_SRC python
  .rotate()
#+END_SRC
** Select element under the mouse, deselect everything is there's nothing under the mouse
#+BEGIN_SRC python
  .select_or_deselect_all(extend=False, toggle=False, deselect=False, center=False, enumerate=False, object=False)
#+END_SRC
** Select items using border selection
#+BEGIN_SRC python
  .select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
#+END_SRC
** Select items using circle selection
#+BEGIN_SRC python
  .select_circle(x=0, y=0, radius=0, gesture_mode=0)
#+END_SRC
** Select items using lasso selection
#+BEGIN_SRC python
  .select_lasso(path=[], deselect=False, extend=True)
#+END_SRC
** Selected objects are saved in a temp file
#+BEGIN_SRC python
  .copybuffer()
#+END_SRC
** Set camera view to active view
#+BEGIN_SRC python
  .camera_to_view()
#+END_SRC
** Set the active object as the active camera for this view or scene
#+BEGIN_SRC python
  .object_as_camera()
#+END_SRC
** Set the boundaries of the border render and enable border render
#+BEGIN_SRC python
  .render_border(xmin=0, xmax=0, ymin=0, ymax=0, camera_only=False)
#+END_SRC
** Set the location of the 3D cursor
#+BEGIN_SRC python
  .cursor3d()
#+END_SRC
** Set the view clipping border
#+BEGIN_SRC python
  .clip_border(xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** Snap cursor to active item
#+BEGIN_SRC python
  .snap_cursor_to_active()
#+END_SRC
** Snap cursor to center of selected item(s)
#+BEGIN_SRC python
  .snap_cursor_to_selected()
#+END_SRC
** Snap cursor to nearest grid division
#+BEGIN_SRC python
  .snap_cursor_to_grid()
#+END_SRC
** Snap cursor to the Center
#+BEGIN_SRC python
  .snap_cursor_to_center()
#+END_SRC
** Snap selected item(s) to cursor
#+BEGIN_SRC python
  .snap_selected_to_cursor(use_offset=True)
#+END_SRC
** Snap selected item(s) to nearest grid division
#+BEGIN_SRC python
  .snap_selected_to_grid()
#+END_SRC
** Start game engine
#+BEGIN_SRC python
  .game_start()
#+END_SRC
** Switch the current view from perspective/orthographic projection
#+BEGIN_SRC python
  .view_persportho()
#+END_SRC
** Toggle display of selected object(s) separately and centered in view
#+BEGIN_SRC python
  .localview()
#+END_SRC
** Toggle layer(s) visibility
#+BEGIN_SRC python
  .layers(nr=1, extend=False, toggle=True)
#+END_SRC
** Toggles the properties panel display
#+BEGIN_SRC python
  .properties()
#+END_SRC
** Toggles tool shelf display
#+BEGIN_SRC python
  .toolshelf()
#+END_SRC
** Use a preset viewpoint
#+BEGIN_SRC python
  .viewnumpad(type='FRONT', align_active=False)
#+END_SRC
** View all objects in scene
#+BEGIN_SRC python
  .view_all(use_all_regions=False, center=False)
#+END_SRC
** Zoom in the view to the nearest object contained in the border
#+BEGIN_SRC python
  .zoom_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
#+END_SRC
** Zoom in/out in the view
#+BEGIN_SRC python
  .zoom(delta=0, mx=0, my=0)
#+END_SRC
** smoothview
#+BEGIN_SRC python
  .smoothview()
#+END_SRC
* bpy.ops.wm
** Add a Key-config Preset
#+BEGIN_SRC python
  .keyconfig_preset_add(remove_active=False, name="")
#+END_SRC
** Add a theme preset
#+BEGIN_SRC python
  .interface_theme_preset_add(remove_active=False, name="")
#+END_SRC
** Add an Application Interaction Preset
#+BEGIN_SRC python
  .interaction_preset_add(remove_active=False, name="")
#+END_SRC
** Add an Operator Preset
#+BEGIN_SRC python
  .operator_preset_add(remove_active=False, name="", operator="")
#+END_SRC
** Add key map item
#+BEGIN_SRC python
  .keyitem_add()
#+END_SRC
** Add path to exclude from autoexecution
#+BEGIN_SRC python
  .userpref_autoexec_path_add()
#+END_SRC
** Adjust arbitrary values with mouse input
#+BEGIN_SRC python
  .context_modal_mouse(data_path_iter="", data_path_item="", header_text="", input_scale=0.01, invert=False, initial_x=0)
#+END_SRC
** Call (draw) a pre-defined menu
#+BEGIN_SRC python
  .call_menu(name="")
#+END_SRC
** Change NDOF sensitivity
#+BEGIN_SRC python
  .ndof_sensitivity_change(decrease=True, fast=False)
#+END_SRC
** Copy settings from previous version
#+BEGIN_SRC python
  .copy_prev_settings()
#+END_SRC
** Delete the addon from the file system
#+BEGIN_SRC python
  .addon_remove(module="")
#+END_SRC
** Disable an addon
#+BEGIN_SRC python
  .addon_disable(module="")
#+END_SRC
** Display more information on this addon
#+BEGIN_SRC python
  .addon_expand(module="")
#+END_SRC
** Duplicate the current Blender window
#+BEGIN_SRC python
  .window_duplicate()
#+END_SRC
** Enable an addon
#+BEGIN_SRC python
  .addon_enable(module="")
#+END_SRC
** Export key configuration to a python script
#+BEGIN_SRC python
  .keyconfig_export(filepath="keymap.py", filter_folder=True, filter_text=True, filter_python=True)
#+END_SRC
** Generate System Info
#+BEGIN_SRC python
  .sysinfo()
#+END_SRC
** Import key configuration from a python script
#+BEGIN_SRC python
  .keyconfig_import(filepath="keymap.py", filter_folder=True, filter_text=True, filter_python=True, keep_original=True)
#+END_SRC
** Install an addon
#+BEGIN_SRC python
  .addon_install(overwrite=True, target='DEFAULT', filepath="", filter_folder=True, filter_python=True, filter_glob="*.py;*.zip")
#+END_SRC
** Internal use (edit a property data_path)
#+BEGIN_SRC python
  .properties_remove(data_path="", property="")
#+END_SRC
** Jump to a different tab inside the properties editor
#+BEGIN_SRC python
  .properties_context_change(context="")
#+END_SRC
** Launch the blender-player with the current blend-file
#+BEGIN_SRC python
  .blenderplayer_start()
#+END_SRC
** Link or Append from a Library .blend file
#+BEGIN_SRC python
  .link_append(filepath="", directory="", filename="", files=[], filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=1, relative_path=True, display_type='FILE_DEFAULTDISPLAY', link=True, autoselect=True, active_layer=True, instance_groups=True)
#+END_SRC
** Load a Collada file
#+BEGIN_SRC python
  .collada_import(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=True, filter_folder=True, filemode=8, display_type='FILE_DEFAULTDISPLAY', import_units=False)
#+END_SRC
** Load and apply a Blender XML theme file
#+BEGIN_SRC python
  .theme_install(overwrite=True, filepath="", filter_folder=True, filter_glob="*.xml")
#+END_SRC
** Load default file and user preferences
#+BEGIN_SRC python
  .read_factory_settings()
#+END_SRC
** Load online manual
#+BEGIN_SRC python
  .doc_view_manual(doc_id="")
#+END_SRC
** Load online reference docs
#+BEGIN_SRC python
  .doc_view(doc_id="")
#+END_SRC
** Make the current file the default .blend file, includes preferences
#+BEGIN_SRC python
  .save_homefile()
#+END_SRC
** Open a Blender file
#+BEGIN_SRC python
  .open_mainfile(filepath="", filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=8, display_type='FILE_DEFAULTDISPLAY', load_ui=True, use_scripts=True)
#+END_SRC
** Open a path in a file browser
#+BEGIN_SRC python
  .path_open(filepath="")
#+END_SRC
** Open a popup to set the debug level
#+BEGIN_SRC python
  .debug_menu(debug_value=0)
#+END_SRC
** Open a website in the web-browser
#+BEGIN_SRC python
  .url_open(url="")
#+END_SRC
** Open an automatically saved file to recover it
#+BEGIN_SRC python
  .recover_auto_save(filepath="", filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=False, filemode=8, display_type='FILE_LONGDISPLAY')
#+END_SRC
** Open the default file (doesn't save the current file)
#+BEGIN_SRC python
  .read_homefile()
#+END_SRC
** Open the last closed file ("quit.blend")
#+BEGIN_SRC python
  .recover_last_session()
#+END_SRC
** Opens a blocking popup region with release info
#+BEGIN_SRC python
  .splash()
#+END_SRC
** Pop-up a search menu over all available operators in current context
#+BEGIN_SRC python
  .search_menu()
#+END_SRC
** Print dependency graph relations to the console
#+BEGIN_SRC python
  .dependency_relations()
#+END_SRC
** Print memory statistics to the console
#+BEGIN_SRC python
  .memory_statistics()
#+END_SRC
** Quit Blender
#+BEGIN_SRC python
  .quit_blender()
#+END_SRC
** Reloads history and bookmarks
#+BEGIN_SRC python
  .read_history()
#+END_SRC
** Remove key config
#+BEGIN_SRC python
  .keyconfig_remove()
#+END_SRC
** Remove key map item
#+BEGIN_SRC python
  .keyitem_remove(item_id=0)
#+END_SRC
** Remove path to exclude from autoexecution
#+BEGIN_SRC python
  .userpref_autoexec_path_remove(index=0)
#+END_SRC
** Restore key map item
#+BEGIN_SRC python
  .keyitem_restore(item_id=0)
#+END_SRC
** Restore key map(s)
#+BEGIN_SRC python
  .keymap_restore(all=False)
#+END_SRC
** Save a Collada file
#+BEGIN_SRC python
  .collada_export(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=True, filter_folder=True, filemode=8, display_type='FILE_DEFAULTDISPLAY', apply_modifiers=False, export_mesh_type=0, export_mesh_type_selection='view', selected=False, include_children=False, include_armatures=False, include_shapekeys=True, deform_bones_only=False, active_uv_only=False, include_uv_textures=False, include_material_textures=False, use_texture_copies=True, triangulate=True, use_object_instantiation=True, sort_by_name=False, export_transformation_type=0, export_transformation_type_selection='matrix', open_sim=False)
#+END_SRC
** Save the current Blender file
#+BEGIN_SRC python
  .save_mainfile(filepath="", check_existing=True, filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=8, display_type='FILE_DEFAULTDISPLAY', compress=False, relative_remap=False)
#+END_SRC
** Save the current file in the desired location
#+BEGIN_SRC python
  .save_as_mainfile(filepath="", check_existing=True, filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_folder=True, filemode=8, display_type='FILE_DEFAULTDISPLAY', compress=False, relative_remap=True, copy=False, use_mesh_compat=False)
#+END_SRC
** Save user preferences separately, overrides startup file preferences
#+BEGIN_SRC python
  .save_userpref()
#+END_SRC
** Scale an int context value
#+BEGIN_SRC python
  .context_scale_int(data_path="", value=1, always_step=True)
#+END_SRC
** Scan addon directories for new modules
#+BEGIN_SRC python
  .addon_refresh()
#+END_SRC
** Set a context array value (useful for cycling the active mesh edit mode)
#+BEGIN_SRC python
  .context_cycle_array(data_path="", reverse=False)
#+END_SRC
** Set a context value
#+BEGIN_SRC python
  .context_set_boolean(data_path="", value=True)
#+END_SRC
** Set a context value
#+BEGIN_SRC python
  .context_set_enum(data_path="", value="")
#+END_SRC
** Set a context value
#+BEGIN_SRC python
  .context_set_float(data_path="", value=0, relative=False)
#+END_SRC
** Set a context value
#+BEGIN_SRC python
  .context_set_int(data_path="", value=0, relative=False)
#+END_SRC
** Set a context value
#+BEGIN_SRC python
  .context_set_string(data_path="", value="")
#+END_SRC
** Set a context value
#+BEGIN_SRC python
  .context_set_value(data_path="", value="")
#+END_SRC
** Set a context value (useful for cycling active material, vertex keys, groups, etc.)
#+BEGIN_SRC python
  .context_cycle_int(data_path="", reverse=False)
#+END_SRC
** Set a context value to an ID data-block
#+BEGIN_SRC python
  .context_set_id(data_path="", value="")
#+END_SRC
** Set boolean values for a collection of items
#+BEGIN_SRC python
  .context_collection_boolean_set(data_path_iter="", data_path_item="", type='TOGGLE')
#+END_SRC
** Set some size property (like e.g. brush size) with mouse wheel
#+BEGIN_SRC python
  .radial_control(data_path_primary="", data_path_secondary="", use_secondary="", rotation_path="", color_path="", fill_color_path="", zoom_path="", image_id="", secondary_tex=False)
#+END_SRC
** Set the active operator to its default values
#+BEGIN_SRC python
  .operator_defaults()
#+END_SRC
** Simple redraw timer to test the speed of updating the interface
#+BEGIN_SRC python
  .redraw_timer(type='DRAW', iterations=10)
#+END_SRC
** Test key-config for conflicts
#+BEGIN_SRC python
  .keyconfig_test()
#+END_SRC
** Toggle a context value
#+BEGIN_SRC python
  .context_cycle_enum(data_path="", reverse=False)
#+END_SRC
** Toggle a context value
#+BEGIN_SRC python
  .context_toggle(data_path="")
#+END_SRC
** Toggle a context value
#+BEGIN_SRC python
  .context_toggle_enum(data_path="", value_1="", value_2="")
#+END_SRC
** Toggle the current window fullscreen
#+BEGIN_SRC python
  .window_fullscreen_toggle()
#+END_SRC
** appconfig_activate
#+BEGIN_SRC python
  .appconfig_activate(filepath="")
#+END_SRC
** appconfig_default
#+BEGIN_SRC python
  .appconfig_default()
#+END_SRC
** context_menu_enum
#+BEGIN_SRC python
  .context_menu_enum(data_path="")
#+END_SRC
** keyconfig_activate
#+BEGIN_SRC python
  .keyconfig_activate(filepath="")
#+END_SRC
** operator_cheat_sheet
#+BEGIN_SRC python
  .operator_cheat_sheet()
#+END_SRC
** properties_add
#+BEGIN_SRC python
  .properties_add(data_path="")
#+END_SRC
** properties_edit
#+BEGIN_SRC python
  .properties_edit(data_path="", property="", value="", min=0, max=1, description="")
#+END_SRC
* bpy.ops.world
** Add a new world
#+BEGIN_SRC python
  .new()
#+END_SRC
